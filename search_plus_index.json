{"./":{"url":"./","title":"简介","keywords":"","body":"My pythonnoteintroduction This is winnerzr's Psnote. It mainly show you some pythonnoteskills,which was learned through studying. Welcome to star and fork. My hexo blog is Winnerzr. My github link Winnerzr. It is a book powered by GitBook. The software used in the experiment is python. All resources come from the network, do not assume any responsibility, the author just to organize the collection, refused to sell. Your support is the driving force of my creation. © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"micropythonnote.html":{"url":"micropythonnote.html","title":"Micropython","keywords":"","body":" Micropython TPYBoard v202快速上手 TPYBoard v202简介 TPYBoard v202 GPIO的使用 TPYBoard v202 Network连接网络 TPYBoard v202 连接Putty教程 TPYBoard v202 定时器 TPYBoard v202 舵机的基本介绍 TPYBoard v202 I2C操作DS3231时钟模块 TPYBoard v202 HTTP协议 TPYBoard v202 微信远程 TPYBoard v202 MQTT协议1 TPYBoard v202 MQTT协议2 TPYBoard v202 家庭气象站 TPYBoard制作廉价WIFI干扰器 TPYBorad用单片机实现一次完整的wifi攻击 TPYBoard v202 实现家庭智能控制平台 TPYBoard v202 固件的检查与擦除 TPYBoard v202 固件烧写 TPYBoard v202 智能WIFI远控小车 参考资料 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202快速上手.html":{"url":"TPYBoard v202快速上手.html","title":"TPYBoard v202快速上手","keywords":"","body":"1. TPYBoard v202快速上手 打开对应端口 将main.py加载到Tpyboard 运行完下面的程序，可以搜索到名为“TPYBoard v202”的WIFI，并可以成功连接。 import network # 将v202设置成AP模式 ap_if = network.WLAN(network.AP_IF) # 激活接口 ap_if.active(True) # 开放WIFI。名称:TPYBoard v202 密码:12345678 ap_if.config(essid='TPYBoard v202',password='12345678') © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202简介.html":{"url":"TPYBoard v202简介.html","title":"TPYBoard v202简介","keywords":"","body":"2. TPYBoard v202简介 TPYBoard v202是遵照MIT协议，以MicroPython为基础，研发的一款支持Python和lua语言的Wifi通信开发板，TPYBoard v202有9个通用GPIO口，1费ADC接口，1个SPI接口，1个I2C 接口，1个USART接口。 通用方法 machine类库： import machine machine.freq() # 获取CPU的频率 machine.freq(160000000) # 设置CPU频率为 160 MHz esp类库： import esp esp.osdebug(None) # 关闭供应商O/S调试消息 esp.osdebug(0) # 将供应商O/S调试消息重定向到UART（0） 联网 network类库： AP模式: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。AP和AP之间允许相互连接 STA模式: Station, 类似于无线终端，STA本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式。 简单地说，AP模式指的是可以将板子当作路由器来使用，STA模式指的是将板子连接到wifi上网 import network wlan = network.WLAN(network.STA_IF) # 将v202设置成STA模式 wlan.active(True) # 激活接口 wlan.scan() # 扫描当前可用WiFi wlan.isconnected() # 检查工作站是否连接到AP wlan.connect('essid', 'password') # 连接WiFi名称，WiFi密码 wlan.config('mac') # 得到接口对应的mac地址 wlan.ifconfig() # 得到接口的IP地址、网络掩码、网关、DNS地址 ap = network.WLAN(network.AP_IF) # 创建可用接口 ap.active(True) # 激活接口 ap.config(essid='ESP-AP') # 设置开发板的WiFi名称 连接到本地WiFi网络： def do_connect(): import network wlan = network.WLAN(network.STA_IF) wlan.active(True) if not wlan.isconnected(): print('connecting to network...') wlan.connect('essid', 'password') # 连接WiFi名称，WiFi密码 while not wlan.isconnected(): pass print('network config:', wlan.ifconfig()) 延迟和时间 time 类库 import time time.sleep(1) # 延时一秒 time.sleep_ms(500) # 延时500毫秒 time.sleep_us(10) # 延时10微秒 start = time.ticks_ms() # 获取毫秒计数器 delta = time.ticks_diff(time.ticks_ms(), start) # 计算时间差，精确到毫秒级 计时器 import time time.sleep(1) # sleep for 1 second time.sleep_ms(500) # sleep for 500 milliseconds time.sleep_us(10) # sleep for 10 microseconds start = time.ticks_ms() # get millisecond counter delta = time.ticks_diff(time.ticks_ms(), start) # compute time difference 周期以毫秒为单位。 引脚和GPIO 使用machine.Pin类库： from machine import Pin p0 = Pin(0, Pin.OUT) # 将GPIO0设置为输出模式 p0.high() # 设置引脚为高电位 p0.low() # 设置引脚为低电位 p0.value(1) p2 = Pin(2, Pin.IN) # 将GPIO2设置为输入模式 print(p2.value()) # 得到引脚对应的高低电平信息 p4 = Pin(4, Pin.IN, Pin.PULL_UP) # e启动内部上拉电阻 led = Pin(2, Pin.OUT) led.on() # 熄灭灯 led.off() # 点亮灯 led.value(1) # 熄灭灯 led.value(0) # 点亮灯 # 即低电平有效，高电平无效 可用引脚为：0,1,2,3,4,5,12,13,14,15,16，其对应于ESP8266芯片的实际GPIO引脚号。请注意，许多终端用户板使用自己的adhoc引脚编号（标记为D0，D1，...）。由于MicroPython支持不同的单板和模块，所以选择物理引脚编号作为最低的公分母。对于逻辑引脚和物理芯片引脚之间的映射，请参阅电路板文档。 注意，引脚（1）和引脚（3）分别是REPL UART TX和RX。还要注意，Pin（16）是一个特殊的引脚（用于从深睡眠模式唤醒），可能不适用于更高级别的类 Neopixel。 PWM（脉宽调制） 除引脚（16）外的所有引脚都可以使能PWM。所有通道都有一个频率，范围介于1到1000（以Hz为单位）。占空比介于0和1023之间。duty属于[0，1023] 使用machine.PWM类： from machine import Pin, PWM pwm0 = PWM(Pin(0)) # 从当前引脚创建PWM对象 pwm0.freq() # 获取当前频率 pwm0.freq(1000) # 设置频率 pwm0.duty() # 获取当前占空比 pwm0.duty(200) # 设置占空比 pwm0.deinit() # 关闭引脚的PWM功能 pwm2 = PWM(Pin(2), freq=500, duty=512) # create and configure in one go ADC（模数转换） ADC在专用引脚上可用。请注意，ADC引脚上的输入电压必须在0v和1.0v之间。read()返回的值属于0（0.0伏）到1024（1.0伏）。注意输入最大只能为1伏电压，当你想要测量更大的电压时必须使用分压电路（voltage divider circuit）。 使用machine.ADC类： from machine import ADC adc = ADC(0) # create ADC object on ADC pin adc.read() # read value, 0-1024 SPI总线 有两个SPI驱动程序。 一个在软件（bit-banging）中实现，并可在所有引脚上工作： from machine import Pin, SPI # construct an SPI bus on the given pins# polarity is the idle state of SCK# phase=0 means sample on the first edge of SCK, phase=1 means the second spi = SPI(-1, baudrate=100000, polarity=1, phase=0, sck=Pin(0), mosi=Pin(2), miso=Pin(4)) spi.init(baudrate=200000) # set the baudrate spi.read(10) # read 10 bytes on MISO spi.read(10, 0xff) # read 10 bytes while outputing 0xff on MOSI buf = bytearray(50) # create a buffer spi.readinto(buf) # read into the given buffer (reads 50 bytes in this case)spi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI spi.write(b'12345') # write 5 bytes on MOSI buf = bytearray(4) # create a buffer spi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer spi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf 硬件SPI更快（高达80Mhz），但仅适用于以下引脚： MISO is GPIO12， MOSI is GPIO13，SCK is GPIO14。它具有与上述bitbanging SPI类相同的方法，除了构造函数和init的引脚参数（正如固定的那样）： from machine import Pin, SPI hspi = SPI(1, baudrate=80000000, polarity=0, phase=0) # 设置波特率 I2C总线 I2C驱动程序通过以下程序来实现，并可在TPYBoard v202所有引脚上工作： from machine import Pin, I2C # construct an I2C bus i2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000) i2c.readfrom(0x3a, 4) # read 4 bytes from slave device with address 0x3a i2c.writeto(0x3a, '12') # write '12' to slave device with address 0x3a buf = bytearray(10) # create a buffer with 10 bytes i2c.writeto(0x3a, buf) # write the given buffer to the slave 深度睡眠模式 将GPIO16连接到复位引脚（RST）。可以使用以下代码进行睡眠，唤醒并检查复位原因： 从深睡眠中唤醒后，所有之前的记忆都被抹除，不过会boot.py一如既往地执行，你可以编写代码使得在被唤醒后做一些事情。比如打印唤醒的模式，使用以下代码： import machine # configure RTC.ALARM0 to be able to wake the device rtc = machine.RTC()rtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP) # check if the device woke from a deep sleepif machine.reset_cause() == machine.DEEPSLEEP_RESET: print('woke from a deep sleep') # set RTC.ALARM0 to fire after 10 seconds (waking the device) rtc.alarm(rtc.ALARM0, 10000) # put the device to sleep machine.deepsleep() OneWire驱动 OneWire驱动程序通过以下程序实现，并可在TPYBoard v202所有引脚上工作： from machine import Pinimport onewire ow = onewire.OneWire(Pin(12)) # create a OneWire bus on GPIO12 ow.scan() # return a list of devices on the bus ow.reset() # reset the bus ow.readbyte() # read a byte ow.writebyte(0x12) # write a byte on the bus ow.write('123') # write bytes on the bus ow.select_rom(b'12345678') # select a specific device by its ROM code DS18S20和DS18B20的驱动程序： import time, ds18x20 ds = ds18x20.DS18X20(ow) roms = ds.scan() ds.convert_temp() time.sleep_ms(750) for rom in roms: print(ds.read_temp(rom)) 确保在数据线上放置4.7k的上拉电阻。请注意，convert_temp()每次要采样温度时都必须调用该方法。 NeoPixel驱动 使用neopixel类库： from machine import Pin from neopixel import NeoPixel pin = Pin(0, Pin.OUT) # set GPIO0 to output to drive NeoPixels np = NeoPixel(pin, 8) # create NeoPixel driver on GPIO0 for 8 pixels np[0] = (255, 255, 255) # set the first pixel to white np.write() # write data to all pixels r, g, b = np[0] # get first pixel colour 对于NeoPixel的入门使用： import esp esp.neopixel_write(pin, grb_buf, is800khz) APA102驱动 使用apa102类库： from machine import Pin from apa102 import APA102 clock = Pin(14, Pin.OUT) # set GPIO14 to output to drive the clock data = Pin(13, Pin.OUT) # set GPIO13 to output to drive the data apa = APA102(clock, data, 8) # create APA102 driver on the clock and the data pin for 8 pixels apa[0] = (255, 255, 255, 31) # set the first pixel to white with a maximum brightness of 31apa.write() # write data to all pixels r, g, b, brightness = apa[0] # get first pixel colour 对于APA102的入门使用： import esp esp.apa102_write(clock_pin, data_pin, rgbi_buf) DHT驱动 DHT驱动程序通过以下代码实现，并可在TPYBoard v202所有引脚上工作： import dhtimport machine d = dht.DHT11(machine.Pin(4)) d.measure()d.temperature() # eg. 23 (째C) d.humidity() # eg. 41 (% RH) d = dht.DHT22(machine.Pin(4)) d.measure()d.temperature() # eg. 23.6 (째C) d.humidity() # eg. 41.3 (% RH) © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 GPIO的使用.html":{"url":"TPYBoard v202 GPIO的使用.html","title":"TPYBoard v202 GPIO的使用","keywords":"","body":"3.TPYBoard v202 GPIO的使用 3.1GPIO的介绍 GPIO（General Purpose I/O Ports）意思为通用输入/输出端口，通俗地说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态-是高电平或是低电平。 通过上图大家可以看到开发板上的ESP8266模块上有一个蓝色的LED灯，它与板子的G2引脚相连。当控制G2输出低电平时，LED点亮，反之熄灭。开发板上有两个按键，RST按键和FLASH按键。 RST按键：复位按键，用于开发板的硬复位 FLASH按键：FLASH按键，主要与RST按键搭配使用，使开发板进入烧录模式，与G0引脚相连 TPYBoard v202开发板支持MicroPython开发，同时也只支持Lua语言开发。为了方便大家使用，下表列举了TPYBoard v202开发板上的引脚编号与NodeMCU、MicroPython之间的对应关系。 可用于GPIO操作的引脚有：G0,G2,G4,G5,G12,G13,G14,G15,G16，其中G16是一个特殊的引脚，用于从深度睡眠模式唤醒模块。还需要注意一点，开发板上只有一个串口，将其引出为USB虚拟串口用于REPL操作，当你需要使用串口时，应注意避免冲突。 实现功能：运行新程序后，你会看到板载的蓝色LED灯会每隔3秒亮灭一次，并一直循环下去。 from machine import Pin import time p2 = Pin(2, Pin.OUT) # 创建一个引脚对象p2，使用GPIO2（G2）引脚，输出模式 p2.value(1) # 设置引脚输出高电平，即板载蓝色LED熄灭 while True: p2.value(0) # 设置引脚输出低电平，即板载蓝色LED点亮 print(p2.value()) # 读取引脚的电平值，并打印 time.sleep(3) # 延时3秒 p2.value(1) print(p2.value()) time.sleep(3) © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 Network连接网络.html":{"url":"TPYBoard v202 Network连接网络.html","title":"TPYBoard v202 Network连接网络","keywords":"","body":"4.TPYBoard v202 Network连接网络 Network库的使用方法 网络模块用于配置WiFi连接。一共两种模式，模式一:是TPYBoard v202当STA节点，即连接路由器的节点。模式二，是TPYBoard v202做为AP，充当路由. TPYBoard v202 STA节点模式 import network wlan = network.WLAN(network.STA_IF) # 创建一个站（当ESP8266连接到路由器时）接口 wlan.active(True) # 激活接口 wlan.scan() # 扫描接入点 wlan.isconnected() # 检查站点是否连接到路由器 wlan.connect('essid', 'password') # 连接到路由器,设置名称密码 wlan.config('mac') # 获取接口的MAC地址 wlan.ifconfig() # 获取接口的IP / netmask / gw / DNS地址 #检查是否连接是否建立 wlan.isconnected() #检查接口是否活动 wlan.active() #检查接口的网络设置 wlan.ifconfig() TPYBoard v202自动连接本地网络: from machine import Pin import network import time def led_state(): p2 = Pin(2, Pin.OUT) p2.value(0) # 点亮LED time.sleep_ms(500) p2.value(1) # 熄灭LED time.sleep_ms(500) p2.value(0) # 点亮LED time.sleep_ms(500) p2.value(1) # 熄灭LED time.sleep_ms(500) def do_connect(): sta_if = network.WLAN(network.STA_IF) p2 = Pin(2, Pin.OUT) sta_if.active(False) if not sta_if.isconnected(): p2.value(0) print('connecting to network...') sta_if.active(True) sta_if.connect('TurnipSmart', 'turnip2016') while not sta_if.isconnected(): pass if sta_if.isconnected(): print('connect success') led_state() print('network config:', sta_if.ifconfig()) do_connect() TPYBoard v202 AP模式 import network ap = network.WLAN(network.AP_IF) ＃创建接入点接口 ap.active(True) # 激活接口 ap.config(essid='ESP-AP',password='123456') # 设计接入点的ESSID，密码为123456 也可以设置无密码开放模式，如下： ap.config(essid='ESP-AP',authmode=0) # 设计接入点的ESSID，开放无密码模式 AuthMode有五种模式： 0 : OPEN 1 : WEP 2 : WPA-PSK 3 : WPA2-PSK 4 : WPA/WPA2-PSK 实验一 实验要求： 当TPYBoard v202未连接到网络时，LED亮起警示，当连接成功后，熄灭。 main.py程序代码： import network from machine import Pin sta_if = network.WLAN(network.STA_IF) p2 = Pin(2, Pin.OUT) #我们在这里把接入点接口禁用，方便观看实验效果，非实验可以去掉 sta_if.active(False) if not sta_if.isconnected(): p2.value(0) print('connecting to network...') sta_if.active(True) sta_if.connect('TurnipSmart', 'turnip2016') while not sta_if.isconnected(): pass if sta_if.isconnected(): print('connect success') p2.value(1) print('network config:', sta_if.ifconfig()) 实验要求： import network from machine import Pin sta_if = network.WLAN(network.STA_IF) p2 = Pin(2, Pin.OUT) #我们在这里把接入点接口禁用，方便观看实验效果，非实验可以去掉 sta_if.active(False) if not sta_if.isconnected(): p2.value(0) print('connecting to network...') sta_if.active(True) sta_if.connect('TurnipSmart', 'turnip2016') while not sta_if.isconnected(): pass if sta_if.isconnected(): print('connect success') p2.value(1) print('network config:', sta_if.ifconfig()) 实验二 实验要求 当TPYBoard v202连接网络成功后，通过get方式向网址 test 发起请求，带有一个参数val。 网站接收到请求后，判断参数val的值是否等于字符A，等于的话返回begin，反之返回error。TPYBoard v202收到begin后LED快闪2次。 发起HTTP GET请求的简单方法 def http_get(url): _, _, host, path = url.split('/', 3) addr = socket.getaddrinfo(host, 80)[0][-1] s = socket.socket() s.connect(addr) s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, host), 'utf8')) while True: data = s.recv(100) if data: print(str(data, 'utf8'), end='') else: break s.close() main.py程序代码 import network from machine import Pin import socket import urllib import time def led_state(): p2 = Pin(2, Pin.OUT) p2.value(0) time.sleep_ms(500) p2.value(1) time.sleep_ms(500) p2.value(0) time.sleep_ms(500) p2.value(1) def do_connect(): sta_if = network.WLAN(network.STA_IF) p2 = Pin(2, Pin.OUT) sta_if.active(False) if not sta_if.isconnected(): p2.value(0) print('connecting to network...') sta_if.active(True) sta_if.connect('essid', 'pwd') while not sta_if.isconnected(): pass if sta_if.isconnected(): print('connect success') p2.value(1) print('network config:', sta_if.ifconfig()) def http_get(url): _, _, host, path = url.split('/', 3) addr = socket.getaddrinfo(host, 80)[0][-1] s = socket.socket() s.connect(addr) s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, host), 'utf8')) while True: data = s.recv(50) if data: recive=str(data, 'utf8') #print('recive:',recive) print(str(data, 'utf8'), end='') if(recive.find('begin')>-1): led_state() else: break s.close() do_connect() http_get('http://old.tpyboard.com/esp8266/test.php?val=A') © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 连接Putty教程.html":{"url":"TPYBoard v202 连接Putty教程.html","title":"TPYBoard v202 连接Putty教程","keywords":"","body":"5.TPYBoard v202 连接Putty教程 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 定时器.html":{"url":"TPYBoard v202 定时器.html","title":"TPYBoard v202 定时器","keywords":"","body":"6.TPYBoard v202 定时器 实现方法 增加一个执行一次的定时器 from machine import Timer tim = Timer(-1) #新建一个虚拟定时器 #此处执行时程序会等待5秒打印1，period=5000 以毫秒为单位，mode=Timer.ONE_SHOT 表示只执行一次，callback绑定回调函数 tim.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1)) 增加一个循环定时器 from machine import Timer tim = Timer(-1) #新建一个虚拟定时器 #此方法执行时系统会每隔两秒无限打印2,periodic表示无限打印 tim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2)) 硬件实物 硬件接线图 TPYBoard v202 DHT11温湿度模块 5V VCC G4 DATA GND GND 连接完成后，将下面代码写进TPYBoard v202即可读取当前温湿度的值，下面是源代码: main.py： from machine import Timer import dht import machine d=dht.DHT11(machine.Pin(4)) def f(t): d.measure() a=d.temperature() b=d.humidity() print('温度:',a,'°C') print('湿度:',b,'%') tim = Timer(-1) #新建一个虚拟定时器 tim.init(period=2000, mode=Timer.PERIODIC, callback=f) 使用TPYBoard v202开发工具-MFU，就可以看到每隔2秒钟就会打印一次温湿度数据。若想做一下扩展，可将温湿度显示到OLED显示屏上，这样一个小型的DIY温湿度检测仪就诞生了。 TPYBoard v202 常见问题及使用技巧 TPYBoard v202采用ESP8266-12 E/12F作为主控模块。 Flash大小：32Mbit（4MBit） 温度范围：-20～80°C 天线封装：PCB 工作电压：3.0～3.6V（建议3.3V） 指示灯IO口：GPIO2 默认波特率：115200 支持语言 TPYBoard v202完美支持MicroPython使用Python语言开发，同时兼容NodeMCU也可以使用Lua语言。 接口种类 TPYBoard v202接口类型有：SPI接口1个、IIC接口1个、ADC接口1个、UART 接口 1个。 如何使用串口 源码： from machine import UART u2=UART(0,115200)#串口初始化 u2.readall()#读取串口全部数据 u2.write(‘hello’)#写入串口数据 固件的烧写与擦除 若因为一些操作或意外，导致v202不能正常工作时，可尝试重新烧写固件试试，如果不起作用的话，可以先进行擦除在烧写。 点击查看固件擦除教程 点击查看固件烧写教程 调试工具 v202通过数据线接入电脑后，会安装一个COM串口，这个可以在电脑的设备管理器中看到，如： 因为在v202开发板上加载了CH340（USB转串口）芯片，所以我们只要使用一个支持串口功能终端的软件即可。本人比较推荐的调试工具是Putty。 Putty下载地址: http://tpyboard.com/download/tool/3.html 若有的小伙伴的电脑不能自动安装CH340驱动的话，这里提供一个下载地址，可自行进行安装。 下载地址：http://tpyboard.com/download/drive/163.html 下载程序的工具 TPYBoard v202不像是TPYBoard v102系列的一样，可以自动在电脑上加载一个磁盘，代码文件直接拷贝到磁盘中就可以运行。 TPYBoard v202需要文件下载工具才能将代码下载到Flash内运行。 网上比较流行有两种工具 ESPlorer 它是用Java开发的，使用前需要安装Java运行库，支持Windows、Linux和Mac OS多种系统平台； ESPlorer MicroPython File Uploader 它是用doNET开发的，只支持Windows系统平台。本人比较推荐MicroPython File Uploader，虽然他没有ESPlorer的功能强大，但它是一个小巧快速的ESP8266文件上传工具，上传文件快，同时也支持Putty中调试的功能。 MicroPython File Uploader PWM控制舵机 准备工作： TPYBoard v202 1块 micro USB数据线 1条 SG90舵机 1个 MicroPython File Uploader 点击下载 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 舵机的基本介绍.html":{"url":"TPYBoard v202 舵机的基本介绍.html","title":"TPYBoard v202 舵机的基本介绍","keywords":"","body":"7.TPYBoard v202 舵机的基本介绍 舵机的组成与参数 舵机，又称伺服马达，是一种具有闭环控制系统的机电结构。舵机主要是由外壳、电路板、无核心马达、齿轮与位置检测器所构成。 其工作原理是由控制器发出PWM（脉冲宽度调制）信号给舵机，经电路板上的IC处理后计算出转动方向，再驱动无核心马达转动， 透过减速齿轮将动力传至摆臂，同时由位置检测器（电位器）返回位置信号，判断是否已经到达设定位置，一般舵机只能旋转180度。 舵机的接线 舵机有3根线，棕色为地，红色为电源正，橙色为信号线，但不同牌子的舵机，线的颜色可能不同。 舵机的控制原理 舵机的转动的角度是通过调节PWM（脉冲宽度调制）信号的占空比来实现的。 占空比： 1.指高电平在一个周期之内所占的时间比率。 2.正脉冲的持续时间与脉冲总周期的比值。例如:正脉冲宽度1μs,信号周期10μs的脉冲序列占空比为0.1。即：脉冲的宽度除以脉冲的周期称为占空比。标准PWM（脉冲宽度调制）信号的周期固定为20ms（50Hz），理论上脉宽分布应在1ms到2ms之间，但是，事实上脉宽可由0.5ms到2.5ms之间，脉宽和舵机的转角0°～180°相对应。 硬件的连接 示意图 | TPYBoard V202 | SG90舵机 | | ------------- | ------------ | | +5V | 正极(红色线) | | GND | 负极(棕色线) | | G5 | 信号(橙色线) | 实物图 源代码： 温馨提示:TPYBoard v202开发板上的引脚G9、G10、G16 不支持PWM功能。 main.py： import machine import time #设置PWM 引脚G5,频率50Hz servo = machine.PWM(machine.Pin(5), freq=50) servo.duty(40) # 舵机角度的设定 time.sleep(2) # 延时2秒；转到指定角度 servo.duty(115) # 转过相同差值的角度（75°）115°-40°=180°-115° time.sleep(2) # 延时2秒；转回原来的角度 servo.duty(180) freq:1-1000 脉宽对应舵机角度0°- 180° duty:0-1023 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 I2C操作DS3231时钟模块.html":{"url":"TPYBoard v202 I2C操作DS3231时钟模块.html","title":"TPYBoard v202 I2C操作DS3231时钟模块","keywords":"","body":"8.TPYBoard v202 I2C操作DS3231时钟模块 学习TPYBoard v202中I2C接口的使用方法 学习使用DS3231制作简易的电子时钟 I2C(Inter-Integrated Circuit(集成电路总线)) I2C总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS)。 I2C是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。 MicroPython中I2C类库介绍 from machine import Pin, I2C # construct an I2C bus i2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000) i2c.readfrom(0x3a, 4) # read 4 bytes from slave device with address 0x3a i2c.writeto(0x3a, '12') # write '12' to slave device with address 0x3a buf = bytearray(10) # 创建一个十个字节的缓存区 i2c.writeto(0x3a, buf) # write the given buffer to the slave TPYBoard v202的I2C接口中SCL=Pin(14),SDA=Pin(2)，I2C初始化修改为如下： i2c = I2C(scl=Pin(14), sda=Pin(2), freq=100000) DS3231时钟芯片的基本介绍 DS3231是低成本、高精度I2C实时时钟(RTC)，具有集成的温补晶振(TCXO)和晶体。该器件包含电池输入端，断开主电源时仍可保持精确的计时。 集成晶振提高了器件的长期精确度，并减少了生产线的元件数量。DS3231提供商用级和工业级温度范围，采用16引脚300mil的SO封装。 DS3231内部集成了一个非常精确的数字温度传感器，可通过I2C接口对其进行访问(同读取时间一样)，精度为±3°C。 硬件的连接 示意图 TPYBoard v202 DS3231时钟模块 3.3V VCC GND GND SDA SDA SCL SCL main.py import machine import time from ds3231 import DS3231 ds=DS3231() ds.DATE([17,9,1]) ds.TIME([10,10,10]) while True: print('Date:',ds.DATE()) print('Time:',ds.TIME()) print('TEMP:',ds.TEMP()) time.sleep(5) © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 通过HTTP协议上传温湿度数据.html":{"url":"TPYBoard v202 通过HTTP协议上传温湿度数据.html","title":"TPYBoard v202 HTTP协议","keywords":"","body":"9.TPYBoard v202 通过HTTP协议上传温湿度数据 TPYBoard_V202是以遵照MIT许可的MicroPython为基础，由TurnipSmart公司制作的一款MicroPython开发板，它基于ESP8266，通过USB接口进行数据传输,可在3.5V-6V之间的电压正常工作。让您零基础也能灵活掌握8266模块通信技术！支持Python语言的WiFi通信开发板。 所需原件 TPYBoardV202开发板 一块 DHT11模块 一个 杜邦线 若干 DHT11介绍 DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。传感器包括一个电阻式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。因此该产品具有品质卓越、超快响应、抗干扰能力强、性价比极高等优点。每个DHT11传感器都在极为精确的湿度校验室中进行校准。校准系数以程序的形式存在OTP内存中，传感器内部在检测信号的处理过程中要调用这些校准系数。单线制串行接口，使系统集成变得简易快捷。超小的体积、极低的功耗，使其成为该类应用中，在苛刻应用场合的最佳选择。 对DHT11做了简要介绍，下面再介绍一个这个器件在V202开发板上的使用方法，这个器件的使用方法就简单了，主要是因为v202开发板里面集成了DHT的类库，你在使用DHT11的时候，直接声明一下类库，调用函数，读取数值就可以了。 制作主要过程 制作流程 DHT11模块上面有三根针脚，分别为GND,VCC,OUT，接线对应如下表： （1）按照上表接好线后，我们开始编辑main.py的代码； （2）首先需要声明我们所用到的类库，例如引脚，时间，接口，这个实验里面我们好用到了网络，机制等等； （3）在我们声明类库完成之后，我们需要进行类库函数的调用，这里我们需要调用的是DHT11读取数据的函数； （4）完成上面的基本准备工作后，需要定义两个我们会用到的函数，简单的说就是开发板连接路由器函数和开发板数据上传函数； （5）完成开发板连接路由器的函数后，调用一下这个函数，这个函数在这次的代码中仅使用一次； （6）接下来建立起整个代码的主循环； （7）在循环中，调用DHT类库中数据测量的函数，随后在函数中读取出温度和湿度的数值，并保存； （8）获取到温湿度后，开始调用之前定义好的开发板数据上传函数，把数据上传至服务器； （9）延时一段时间，在整个循环中不断的读取温湿度，就完成了实时的温湿度监控。 main.py： import dht import machine import network from machine import Pin import socket import urllib import time#声明用到的类库，尤其是dht的类库 d = dht.DHT11(machine.Pin(5))#声明用到类库中的函数，并设置参数 led = Pin(2, Pin.OUT) count=0 def http_get(url):#定义数据上传的函数 _, _, host, path = url.split('/', 3)#分割传进来的参数 addr = socket.getaddrinfo(host, 80)[0][-1]#把传进来的参数处理成符合格式的地址 s = socket.socket() s.connect(addr)#链接地址 s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, host), 'utf8'))#向链接的地址发送数据 while True:#开始数据发送 data = s.recv(50) if data:#数据未发送完成，继续发送 recive=str(data, 'utf8').upper() #print(str(data, 'utf8'), end='') if(recive.find('YES')>-1): print('Send Data OK') else:#数据发送完成，退出while break s.close()#关闭数据连接 def do_connect():#定义开发板连接无线网络的函数 wlan = network.WLAN(network.STA_IF)#设置开发板的网#络模式 wlan.active(True)#打开网络连接 if not wlan.isconnected():#判断是否有网络连接 print('connecting to network...') wlan.connect('无线名称', '密码')#设置想要连接的无线名称和密码 while not wlan.isconnected():#等待连接上无线网络 pass print('network config:', wlan.ifconfig()) do_connect()#调用一次开发板连接无线网络的函数 while True:#开始整个代码的大循环 d.measure()#调用DHT类库中测量数据的函数 temp_=str(d.temperature())#读取measure()函数中的温度数据 hum_=str(d.humidity())#读取measure()函数中的湿度数据 count+=1#计数变量+1 print('eg:',temp_,'-',hum_) http_get('http://old.tpyboard.com/esp8266/SensorTest.php?t='+temp_+'&h='+hum_+'') #调用数据上传函数，把最新测量得到的数据进行上传 print('Count:',count) time.sleep(5) 点击查看上传的数据 下载源码 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 自制微信远程智能温湿度计.html":{"url":"TPYBoard v202 自制微信远程智能温湿度计.html","title":"TPYBoard v202 微信远程","keywords":"","body":"10.TPYBoard v202 自制微信远程智能温湿度计 申请微信推送服务 能否实现微信推送服务的平台有很多，这里我就不一一解释了。我选用了「Server酱」，英文名「ServerChan」。你完全可以选用你认为比较好用的平台。「Server酱」的申请方法： 打开该网址 http://sc.ftqq.com/3.version 开通并使用。 1.登入：用GitHub账号登入网站，点击进入“发送消息”页面，就能获得一个SCKEY。具体见：http://sc.ftqq.com/?c=code 2.绑定：点击“微信推送”页面，扫码关注同时即可完成绑定 3.发消息：往 https://sc.ftqq.com/SCKEY.send 发GET请求，就可以在微信里收到消息啦。 让我们开始DIY温湿度计 少不了的编程 TPYBoard v202主要有两个文件来控制，一个是boot,py，一个是main.py。我们只需要修改这两个文件就可以完成程序的编写。如果你对如何使用TPYBoard v202还不清楚，可以参照此教程：http://docs.tpyboard.com/zh/latest/tpyboard/tutorial/v202/start/。 编写boot脚本 boot.py： import network import utime pdcn = network.WLAN(network.STA_IF) pdcn.active(True) pdcn.connect('wifi账号', 'wifi密码') utime.sleep(5) if pdcn.isconnected(): print(\"WiFi is connected %s.\"%pdcn.ifconfig()[0]) else: pdcn.active(False) utime.sleep(5) print(\"WiFi cannot connect.\") 编写main.py脚本 main.py： import urequests import dht import machine from machine import Pin import time class AlarmSystem: def __init__(self): self.d = dht.DHT11(machine.Pin(5)) def dht11(self): try: self.d.measure() return 'Temp:'+str(self.d.temperature())+'°C---Hum:'+str(self.d.humidity())+'%' except: return '0' def push(self, result): title = \"TPYBoardv202提示您:注意天气变化保持健康心情\" content = 'text='+title+'&'+'desp='+result url=\"https://sc.ftqq.com/你的密钥.send?%s\" % content r = urequests.get(url) r.close() p2=Pin(2,Pin.OUT) a = AlarmSystem() def SendData(): p2.value(not p2.value()) data_= a.dht11() if(data_!='0'): print(data_) a.push(data_) else: print('GET Data Fail') if __name__ == '__main__': while True: SendData() time.sleep(300) 成果分享 到这里，工作完成，方糖就会给你，你就会看到显示的温湿度了。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 MQTT协议1接入OneNET云平台.html":{"url":"TPYBoard v202 MQTT协议1接入OneNET云平台.html","title":"TPYBoard v202 MQTT协议1","keywords":"","body":"11.TPYBoard v202 MQTT协议1:接入OneNET云平台 物联网（Internet of Things，缩写LOT） 是基于互联网、传统电信网等信息承载体，让所有能行使独立功能的普通物体实现互联互通的网络。其应用领域主要包括运输和物流、工业制造、健康医疗、智能环境（家庭、办公、工厂）等，具有十分广阔的市场前景。 物联网的概念最早是在1999年由Kevin Ashton在一次演讲中提出来的，当时他是一个RFID研究机构的执行主任，这家研究机构是在宝洁公司和吉列公司的赞助下成立的。而他本人也因此被称为物联网之父。随后麻省理工学院的Neil Gershenfeld教授出版了一本名为《When things Start to Think》的书。以这些为标志，正式揭开了物联网的序幕。 物联网的英文是Internet of Things，缩写为IoT。这里的“物”指的是我身边一切能与网络联通的物品。例如你带的手表、你骑的共享单车、马路上的汽车、家里的冰箱、路边的路灯、甚至是一棵树。只要一件物品能够与网络相连，它就都是物联网中的“物”。而所谓物联网，就是“物”与人，以及“物”与“物”之间，通过网络来传递和处理信息。 物联网的基本特征从通信对象和过程来看，物与物、人与物之间的信息交互是物联网的核心。物联网的基本特征可概括为整体感知、可靠传输和智能处理 。整体感知—可以利用射频识别、二维码、智能传感器等感知设备感知获取物体的各类信息。可靠传输—通过对互联网、无线网络的融合，将物体的信息实时、准确地传送，以便信息交流、分享。 智能处理—使用各种智能技术，对感知和传送到的数据、信息进行分析处理，实现监测与控制的智能化。根据物联网的以上特征，结合信息科学的观点，围绕信息的流动过程，可以归纳出物联网处理信息的功能: (1)获取信息的功能。主要是信息的感知、识别，信息的感知是指对事物属性状态及其变化方式的知觉和敏感；信息的识别指能把所感受到的事物状态用一定方式表示出来。 (2)传送信息的功能。主要是信息发送、传输、接收等环节，最后把获取的事物状态信息及其变化的方式从时间(或空间)上的一点传送到另一点的任务，这就是常说的通信过程。 (3)处理信息的功能。是指信息的加工过程，利用已有的信息或感知的信息产生新的信息，实际是制定决策的过程。 (4)施效信息的功能。指信息最终发挥效用的过程，有很多的表现形式，比较重要的是通过调节对象事物的状态及其变换方式，始终使对象处于预先设计的状态 。 OneNET平台 是由中国移动打造的PaaS物联网开放平台。平台能够帮助开发者轻松实现设备接入与设备连接，快速完成产品开发部署，为智能硬件、智能家居产品提供完善的物联网解决方案。OneNET平台作为连接和数据的中心，能适应各种传感网络和通信网络，将面向智能家居、可穿戴设备、车联网、移动健康、智能创客等多个领域开放。 中移OneNET，将数据传输协议、数据储存格式等中间层的东西标准化，形成一个统一、开源的设备云平台，标准化、简约化、集成化，减少企业负担的同时为下一阶段的大数据分析提供基础条件。 核心能力输出 OneNET作为设备连接和数据的中心，面向物联网产业上下游企业提供标准化接入和定制化开发，具体能力输出包含2个方面： 硬件侧：平台适配各种网络环境、兼容国内外主流通信协议，定制化支撑私有通信协议，以及完备的SDK包，可支持各类传感器和智能硬件的快速接入和可控触发控制；还提供对智能硬件的网络状态、终端状态、流量情况、位置信息进行全面的管理和监控； 软件侧：平台通过丰富的API、应用孵化器、轻应用行业模板支持各类智能硬件和行业应用的图形化展示、SaaS层软件开发，满足物联网领域数据存储、数据安全、大数据分析等平台级服务需求。 OneNET平台在提供设备连接服务和数据中心服务的基础上进行开放合作，面向智能硬件创客和创业型企业推出硬件社区服务（包括硬件集市、双创云等），以及数据展现、数据分析和应用生成服务；面向重点行业领域/大客户推出行业PaaS服务和提供行业应用定制化开发服务。 IoT PaaS基础能力：提供智能设备自助开发工具、后台技术支持服务、物联网专网、短彩信、位置定位、设备管理、消息分发、远程升级等基础服务 SaaS业务服务：提供第三方应用开发平台，快速实现不同业务需求，借助轻应用孵化器快速搭建Web和APP应用 IoT数据云：提供高扩展的数据库、实时数据处理、智能预测离线数据分析、数据可视化展示等多维度的业务运营服务 开发者社区：高频的开发者社区，汇聚着不同的知识源，集合更多的物联网爱好者，让项目与开发成果开始传播 什么是MQTT协议 早在1999年，IBM的Andy Stanford-Clark博士以及Arcom公司ArlenNipper博士发明了MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）技术 。MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。 实验准备 硬件材料 TPYBoard v202 面包板 数据线 LED发光二极管 软件准备 MicroPython File Uploader用于与开发板的文件传输 第三方库文件： micropython-libumqtt.simpleumqttsimple.py 下载之后的库文件放在E:\\idmdownload\\micropython-lib\\umqtt.simple\\umqtt OneNET平台创建MQTT协议的产品并添加设备。 登录成功进入开发者中心，添加一个新产品。 创建产品 新建设备 编写程序 boot.py： #连接本地网络 def do_connect(): import network sta_if = network.WLAN(network.STA_IF) ap_if = network.WLAN(network.AP_IF) if ap_if.active(): ap_if.active(False) if not sta_if.isconnected(): print('connecting to network...') sta_if.active(True) sta_if.connect('winnerzr','12345678') #wifi的SSID和密码 while not sta_if.isconnected(): pass print('network config:', sta_if.ifconfig()) do_connect() 修改mqtt.py中设备ID、产品ID和APIKEY参数的信息。 mqtt.py： from simple import MQTTClient from machine import Pin import machine import micropython #选择G4引脚 g4 = Pin(4, Pin.OUT, value=0) # MQTT服务器地址域名为：183.230.40.39,不变 SERVER = \"183.230.40.39\" #设备ID CLIENT_ID = \"deviceID\" #随便起个名字 TOPIC = b\"TurnipRobot\" #产品ID username='productID' #产品APIKey: password='APIKey' state = 0 def sub_cb(topic, msg): global state print((topic, msg)) if msg == b\"on\": g4.value(1) state = 1 print(\"1\") elif msg == b\"off\": g4.value(0) state = 0 print(\"0\") elif msg == b\"toggle\":# 切换状态 state = 1 - state g4.value(state) def main(server=SERVER): #端口号为：6002 c = MQTTClient(CLIENT_ID, server,6002,username,password) c.set_callback(sub_cb) c.connect() c.subscribe(TOPIC) print(\"Connected to %s, subscribed to %s topic\" % (server, TOPIC)) try: while 1: c.wait_msg() finally: c.disconnect() main.py： import mqtt mqtt.main() 修改mqtt.py中设备ID、产品ID和APIKEY参数的信息 连接成功： © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 MQTT协议2上传数据点到OneNET平台.html":{"url":"TPYBoard v202 MQTT协议2上传数据点到OneNET平台.html","title":"TPYBoard v202 MQTT协议2","keywords":"","body":"12.TPYBoard v202 MQTT协议2:上传数据点到OneNET平台 实验准备 TPYBoard v202开发板 USB数据线 NotePad ++ 软件（其他编辑工具也可以） MicroPython File Uploader（MFU）软件 在数据点上报之前，我们需要在OneNET云平台上添加一个数据流模板。步骤如下： 上传数据点接下来就要进行数据点的上传了。上传数据点时需要参考协议规则说明，大家可以去OnetNET平台文档中心上下载，OnetNET平台文档中心地址：https://open.iot.10086.cn/doc/art431.html#118。 找到[1.1 说明文档]找到关于MQTT项目中的设备终端接入协议-MQTT进行下载。 数据类型采用JSON格式，主要看[数据类型1(type == 1)格式说明]。 了解完publish报文格式后，找到之前[接入OneNET平台]教程的程序，添加上上传数据点的功能即可。点击下载源程序 修改mqtt.py文件，如下： from simple import MQTTClient from machine import Pin import machine import micropython import json #选择G4引脚 g4 = Pin(4, Pin.OUT, value=0) # MQTT服务器地址域名为：183.230.40.39,不变 SERVER = \"183.230.40.39\" #设备ID CLIENT_ID = \"628004536\" #随便起个名字 TOPIC = b\"TurnipRobot\" #产品ID username='371066' #产品APIKey: password='qljn7oMAVX=d7OrQ9SZyKW2=ruo=' state = 0 #要上报的数据点 message = {'datastreams':[{ 'id':'temperature', 'datapoints':[{'value':35}]} ]} def pubdata(data): j_d = json.dumps(data) j_l = len(j_d) arr = bytearray(j_l + 3) arr[0] = 1 #publish数据类型为json arr[1] = int(j_l / 256) # json数据长度 高位字节 arr[2] = j_l % 256 # json数据长度 低位字节 arr[3:] = j_d.encode('ascii') # json数据 return arr def sub_cb(topic, msg): global state print((topic, msg)) if msg == b\"on\": g4.value(1) state = 1 print(\"1\") elif msg == b\"off\": g4.value(0) state = 0 print(\"0\") elif msg == b\"toggle\": state = 1 - state g4.value(state) def main(server=SERVER): #端口号为：6002 c = MQTTClient(CLIENT_ID, server,6002,username,password) c.set_callback(sub_cb) c.connect() c.subscribe(TOPIC) print(\"Connected to %s, subscribed to %s topic\" % (server, TOPIC)) #publish报文上传数据点 c.publish('$dp',pubdata(message)) print('publish message:',message) try: while 1: c.wait_msg() finally: c.disconnect() 程序解析 def pubdata(data): j_d = json.dumps(data) j_l = len(j_d) arr = bytearray(j_l + 3) arr[0] = 1 #publish数据类型为json arr[1] = int(j_l / 256) # json数据长度 高位字节 arr[2] = j_l % 256 # json数据长度 低位字节 arr[3:] = j_d.encode('ascii') # json数据 return arr 我们自定义一个pubdata方法，该方法的功能是组合成协议要求的报文格式。 c.publish('$dp',pubdata(message)) 设备使用publish报文来上传数据点。$dp为系统上传数据点的指令（2个字节的字符串） 成果展示： 大家可根据上面学习到的内容进行扩展，比如接DHT11温湿度模块等各类传感器，上传温湿度、气压、光照等信息。 OneNET云平台除了支持MQTT协议外，还支持HTTP、TCP透传等多种协议，大家可以尝试添加其他协议的产品进行智能物联的开发。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 家庭气象站.html":{"url":"TPYBoard v202 家庭气象站.html","title":"TPYBoard v202 家庭气象站","keywords":"","body":"13.TPYBoard v202 家庭气象站 一、实验器件 TPYBoard v102 1块 TPYBoard v202 1块 Nokia 5110LCD显示屏 1块 DHT11温湿度传感器 1个 micro USB 数据线 2根 面包板 1块 杜邦线 若干 二、实验步骤 TPYBoard v102连接DHT11，采集温湿度信息； TPYBoard v102将采集到的温湿度信息显示在LCD5110上； TPYBoard v102通过串口将温湿度信息发送给TPYBoard v202； TPYBoard v202 将串口的数据读取出来，同时传递到服务器上。 三、实验方法 Nokia 5110 LCD显示屏说明 LCD5110是一款84x48 的点阵LCD，可以显示4 行汉字。采用串行接口与主处理器进行通信，支持多种串行通信协议（如AVR 单片机的ＳＰI、MCS51 的串口模式０等），传输速率高达4Mbps，可全速写入显示数据。 Nokia 5110 LCD共有8个引脚，不同的板子可能标注的英文略有不同，具体参照如下： DHT11温湿度说明 DHT11是一款有已校准数字信号输出的温湿度传感器。 精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。 DHT11温湿度共有3个引脚，具体参照如下： 四、接线方式 针脚对应图 DHT11和LCD5110的使用方法上面都介绍过了，接下来，就要动手和我们的TPYBoard v102 接起来了。 TPYBoard v102连接LCD5110 TPYBoard v102连接DHT11 TPYBoard v102连接TPYBoard v202 注意: TPYBoard v202只有一个串口，在使用时比较麻烦。因为REPL也是通过串口输出的，有些字符会导致v202的程序停止，或者支持REPL（puuty）等工具会无法使用。使用时，应多注意冲突。 实物连接图 五、源代码 TPYBoard v102 源代码 TPYBoard v102 main.py文件内容如下： #main.py import pyb import upcd8544 from machine import SPI,Pin from dht11 import DHT11 def main(lcd_5110,dht,uart6): data_=dht.read_data() lcd_5110.lcd_write_string(' ',0,1)#添加一个分隔行 lcd_5110.lcd_write_string('Temp:'+data_[0],2,2) lcd_5110.lcd_write_string(' ',0,3) lcd_5110.lcd_write_string(' Hum:'+data_[1],2,4) uart6.write(data_[0]+','+data_[1])#通过串口将数据发送给v202 if __name__ == '__main__': #init UART u6=pyb.UART(6,115200) #init DHT11 dht=DHT11('X12') #init LCD5110 SPI = pyb.SPI(1) RST = pyb.Pin('Y11') CE = pyb.Pin('Y10') DC = pyb.Pin('Y9') LIGHT = pyb.Pin('X4') #DIN=>X8-MOSI/CLK=>X6-SCK #DIN =>SPI(1).MOSI 'X8' data flow (Master out, Slave in) #CLK =>SPI(1).SCK 'X6' SPI clock lcd_5110 = upcd8544.PCD8544(SPI, RST, CE, DC, LIGHT) lcd_5110.lcd_write_string('TPYBoard v102',1,0) while True: main(lcd_5110,dht,u6) pyb.delay(2000) TPYBoard v202 main.py文件内容，如下： import machine import network import socket from machine import Pin from machine import UART import time u2=UART(0,115200)#串口初始化 led = Pin(2, Pin.OUT).value(1)#板载小蓝灯 默认关闭 def http_get(temp,hum): url='http://old.tpyboard.com/esp8266/SensorTest.php?t='+temp+'&h='+hum+'' _, _, host, path = url.split('/', 3) addr = socket.getaddrinfo(host, 80)[0][-1] s = socket.socket() s.connect(addr) s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, host), 'utf8')) while True: data = s.recv(50) if data: recive=str(data, 'utf8').upper() #print(str(data, 'utf8'), end='') if(recive.find('YES')>-1): print('Send Data OK') else: break s.close() def do_connect(): wlan = network.WLAN(network.STA_IF) wlan.active(True) if not wlan.isconnected(): print('connecting to network...') wlan.connect( 'ssid', 'pwd') while not wlan.isconnected(): pass print('network config:', wlan.ifconfig()) do_connect() led = Pin(2, Pin.OUT).value(0)#连接wifi成功 点亮LED while 1: data_=u2.readall() if data_!=None: data_=data_.decode('utf8')#数组转成字符串 data_a=data_.split(',')#分割 temp_=str(data_a[0])#温度 hum_=str(data_a[1])#湿度 http_get(temp_,hum_)#发送给服务器 time.sleep(2) 服务器源码 SensorTest.php 用于接收TPYBoard v202提交的数据。 SensorData.php 用于显示TPYBoard v202上传的数据。 页面下方点击下载源码，获取SensorData.php和SensorTest.php文件。 六、效果图 实物效果图 网页效果图 访问网址 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard制作廉价WIFI干扰器.html":{"url":"TPYBoard制作廉价WIFI干扰器.html","title":"TPYBoard制作廉价WIFI干扰器","keywords":"","body":"14.TPYBoard v202 邪恶改装：TPYBoard制作廉价WIFI干扰器 esp8266可以实现简单的干扰功能，包括断网、复制、欺骗等等 搭建开发环境： 使用esp8266制作的Deauth无限攻击的开源固件，使用arduino开发的 地址 里面包含了arduino IDE（arduino-1.8.2-windows.exe）和固件源码（esp8266_deauther-master.rar）。另外，还需要esp8266开发包（Arduino15.rar）可以从下面链接：http://pan.baidu.com/s/1bpnJMkn 下载。 配置步骤 下载之后解压： 双击安装arduino 安装完毕之后，打开首选项，点击红色区域进入SDK目录 我的路径是：C:\\Users\\Administrator\\AppData\\Local\\Arduino15 将从网盘下载的Arduino15.rar 解压，把里面全部的文件直接覆盖C:\\Users\\Administrator\\AppData\\Local\\Arduino15下文件。 硬件器件的准备 将tpyboard V202与电脑连接，找到arduino IDE菜单里工具—》开发板 在右侧出来的菜单中向下找，会找到一个TPYBoard v202点击选中。 编译烧写固件 解压esp8266_deauther-master.rar，arduino IDE菜单栏 文件-》打开esp8266_deauther-master源码包esp8266_deauther\\esp8266_deauther.ino TPYBoard v202 使用micro USB数据线接入电脑。查看安装的usb转串的端口。打开电脑的设备管理器（这里是COM11） 工具-》端口，选择COM4（根据自己的实际端口号选择） 菜单栏下面的绿色图标菜单区，选择上传，开始编译，烧写固件 等待编译完成，出现下图信息（状态：变为“上传”）时，按住FLASH的同时，按一下RST按键并松开，让TPYBoard v202复位一下，进入烧写模式。继续按着FLASH,出现下面的信息时就可以松开FLASH按键了。 烧写固件时，板子上的蓝色小灯会一直快速闪烁。 烧写完毕后，显示上传成功，板子上的蓝色小LED会停止闪烁。 测试攻击效果 成功烧写固件后，打开无线会搜索到名称为TPYBoard v202 的热点，密码默认tpyboard，进行连接。 连接成功后，打开浏览器输入192.168.4.1 。点击[我已阅读并理解上面的通知]（本次实验只用于测试实验，请谨慎使用）。 网页原版是英文的，为了方便使用，我简单的翻译了一下（wifi SSID和密码也做了修改），下载的压缩包里也有英文原版的。 点击进来以后，首先扫描一下附近的wifi。点击[扫描]。 接下来我们选择一个wifi做一下攻击的测试，为了方便测试是否成功，选择平时经常使用的wifi，我的列表中选择boda。 选择好后，点击最上方菜单栏[攻击]，进入攻击页面。 攻击方式有3种，Deauther、Beacon和Probe-Request。页面最下方有对这3种方式的介绍，Probe-Request实在不知道怎么翻译，大神们可以指点一下。 我们这次使用Deauther方式，阻止客户端连接，点击[START]开始攻击。 找一个手机做一下实验，看是否还能连上boda。 如果是第一次连接的话，会一直停在正在连接的界面上，无法连接成功。 如果原本连接着，会被强迫断线。点击[STOP],停止攻击。停止后，手机成功连接上boda了。 esp8266_deauther里面还带了wifi复制等其他攻击方式，大家可以自己尝试一下。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"用单片机实现一次完整的wifi攻击.html":{"url":"用单片机实现一次完整的wifi攻击.html","title":"TPYBorad用单片机实现一次完整的wifi攻击","keywords":"","body":"15.TPYBoard v202 邪恶改装2：用单片机实现一次完整的wifi攻击 参考网址 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 利用单片机快速实现家庭智能控制平台.html":{"url":"TPYBoard v202 利用单片机快速实现家庭智能控制平台.html","title":"TPYBoard v202 实现家庭智能控制平台","keywords":"","body":"16.TPYBoard v202 利用单片机快速实现家庭智能控制平台 前言 一提到智能家庭，大家可能首先想到的是各种大佬级公司搞的牛逼产品，或者说是创新产品。想想就觉得很复杂，有的用工控机，有的用树莓派，还有的用arduino，不管用什么，都绕不过服务器进行控制，比如yeelink平台，腾讯的智能硬件平台等等。其实，真实实现起来，并没有想想中这么复杂，我们甚至只用一个小的单片机就能实现。 探讨用单片机来实现web服务器的文章通过baidu也能找到几篇，但比较详实的实现方法并没有找到，这里考虑有两种思路可以完成，一种是有线的lan模块，如w5500，这种模块本身就带有web服务的部分功能，使用起来比较简单，但是只能基于lan进行访问。另一种是通过stm32等单片机，配合网络模块来完成。当前我能想到的最简单的方法就是用stm32+esp8266来实现。 基于第一种方法，我觉得受模块性能影响比较大，受限于模块，没有开发感。于是考虑用第二种方法。这个方法里，有人用arduino来完成，这要基于c进行编程。另外，就是考虑用micropython,这样直接可以用python来实现。这里依然使用tpyboard V202。 模拟实现家庭智能家居控制平台 因为没有想好要做一个多么复杂的实验，只是想能模拟一下效果，所有在整个的模块过程中，我选用了tpyboard v202开发板做主控制板，用一个发光二极管来模拟一个台灯（现实中，这里其实可以用一个继电器来控制其它设备的通断电），用一个直流小电机加迷你风扇叶表示模拟电风扇。整个实现还用到了一个三极管（S9014，NPN）来控制直流电机。 硬件的搭建 三极管S9014（NPN）的使用方法 S9014的放大和开关功能，集电极接入v202的3.3V引脚，发射极接入电机某一端，通过给基极高低电平来控制发射极和集电极之间是否导通，从而控制直流电机转动或停止。 利用micropython实现web服务器 main.py： try: import usocket as socket except: import socket import network from machine import UART from machine import Pin led_flag=Pin(2, Pin.OUT)#esp8266模块上的小灯 高电平:灭 低电平:亮 led = Pin(4, Pin.OUT)#发光二极管的控制引脚 motor = Pin(5, Pin.OUT)#直流电机的控制引脚 #初始化 led.value(0) motor.value(0) led_flag.value(1) def do_connect(ssid,pwd): sta_if = network.WLAN(network.STA_IF)#STA 模式 sta_if.active(False) if not sta_if.isconnected():#判断是否连接 sta_if.active(True) sta_if.connect(ssid,pwd)#ssid:WIFI名称 pwd:WIFI 密码 while not sta_if.isconnected(): pass if sta_if.isconnected(): return sta_if.ifconfig()[0] def main(ip_,dev_data,login_data,name,pwd): s = socket.socket() ai = socket.getaddrinfo(ip_, 80) addr = ai[0][-1] s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) s.bind(addr) s.listen(5) led_flag.value(0) #s_data=login_data while True: res = s.accept() client_s = res[0] client_addr = res[1] led_flag.value(1) req =client_s.readline() while True: h = client_s.readline() if h == b\"\" or h == b\"\\r\\n\": break #print(h) req+=(h.decode('utf-8')) print(\"Request:\") req=req.lower() req=req.decode('utf-8').split('\\r\\n') #http header 解析 req_data=req[0].lstrip().rstrip().replace(' ','') print(req_data) if req_data.find('favicon.ico')>-1: client_s.close() continue else: if len(req_data)-1 and _pwd>-1: #判断是否是用户登录 if req_data.find(name)>-1 and req_data.find(pwd)>-1: s_data=dev_data print('Login Success!') else: f=open('fail.html','r') s_data=f.read() f.close() print('Login Fail!') else: #判断是否是控制LED _index=req_data.find('led=') if _index>-1: s_data=dev_data led_val=req_data[_index+4:_index+6].lstrip().rstrip() print('led:',led_val) if led_val=='on': led.value(1) else: led.value(0) print('led:',led.value()) #判断是否是控制电机 _index=req_data.find('motor=') if _index>-1: s_data=dev_data motor_val=req_data[_index+6:_index+8].lstrip().rstrip() print('motor_val:',motor_val) if motor_val=='on': motor.value(1) else: motor.value(0) print('motor:',motor.value()) print('-----------') client_s.send(s_data) client_s.close() led_flag.value(0) f=open('device.html','r') dev_html=f.read() f.close() f=open('login.html','r') login_html=f.read() f.close() f=open('info.txt','r') info=f.read() f.close() name=info.split(',')[0].lstrip().rstrip() pwd=info.split(',')[1].lstrip().rstrip() print('name:',name) print('pwd:',pwd) myip_=do_connect('essid','password')#家中网络的WIFI名称和密码 print(myip_) main(myip_,dev_html,login_html,name,pwd) info.txt 这里是用文件存放的用户名和密码(英文逗号分隔)，前面是用户名，后面是密码。这里的用户名和密码是用来登录我们 智能家居控制平台的。 admin,123456 程序下载测试 下载完毕后，点击[Run/Reset]就会开始执行代码。 开始运行后，红色框内打印的是我们存放在info.txt里的用户名和密码，这个可以自定义。 下面桃红色框内打印的是我们v202从路由器那里获取到的IP地址，只要打印了IP地址，说明就成功接入网络了。我的v202获取的IP地址是192.168.1.192。到此，我们的web服务器就搭建完成了。 智能家庭网络平台的使用 在家庭局域网内，我们可以选用pc或者手机，通过浏览器，打开192.168.1.192 就可以看到登录界面. 默认用户名 admin 密码123456 ，大家可以通过修改info.txt 文件来进行修改。 错误提示： 正确： 接下来，我们就可以通过网页开控制灯光和小风扇了。 这里，我只是做了一个实例，受时间限制，没有再做更深入的开发。大家可以自己结合自己的创意再深入去做。如果能够通过路由器给tpyboard v202设一个外网Ip，这样就可以从外网进行访问，从而完成外网对家内设备的控制。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 固件的检查与擦除.html":{"url":"TPYBoard v202 固件的检查与擦除.html","title":"TPYBoard v202 固件的检查与擦除","keywords":"","body":"17.TPYBoard v202 固件的检查与擦除 准备工作 TPYBoard v202板子 1块 micro USB数据线 1条 电脑 1台（本次实验以win7为例） PuTTY(工具) 所需器件 TPYBoard v202开发板 1块 USB数据线（MicroUSB） 1条 L298N电机驱动模块 1个 小车套件包（底板、电机等） 1个 18650电池 2节 18650电池盒 1个 固件完整性检查 安装putty 通过USB数据线将电脑和TPYBoard v202开发板连接起来，会自动安装USB转串的驱动。安装完毕后，查看设备管理器，是否正确创建串口。 打开PuTTY，根据下图标记的红色框进行设置。 设置完成后，单击open按钮 按下板子上的rst，进行重置 按下图命令操作 import esp esp.check_fw() 如果最后显示True，代表固件是完整的，否则可能存在问题。如果显示False，最好重新刷一次固件。 详情可参考下一篇文档进行固件的烧写。 固件的擦除 安装Python环境 安装esptool和pyserial，在CMD命令行里运行： pip install esptool 和 pip install pyserial 擦除flash 打开cmd，运行指令： esptool.py --port COM3 erase_flash 注意： 执行擦除的指令前，需要像烧录固件一样，让esp8266进入烧写模式)即按住板上的FLASH键不放，按下RST键松开，当界面显示出MAC地址后，即可松开FLASH按键等待擦除完毕。如果在超时时间内没有让板子进入烧写模式的话 ，就会出现如下的错误提示：A fatal error occurred: Failed to connect to ESP8226 固件成功擦除后，可参考下一篇文档进行固件的烧写。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 固件烧写.html":{"url":"TPYBoard v202 固件烧写.html","title":"TPYBoard v202 固件烧写","keywords":"","body":"18.TPYBoard v202 固件烧写 烧写固件 下载烧写固件所需的软件：在windows系统下可以使用ESPFlashDownloadTool_v3.3.4软件。不用担心不好找，见下面的附件压缩包。 flash_download_tools_v3.3.4_win.zip 连接TPYBoard v202开发板 通过USB数据线将电脑和TPYBoard-esp8266开发板连接起来，会自动安装USB转串的驱动。安装完毕后，查看设备管理器，是否正确创建串口(我的电脑是COM44) 打开ESPFlashDownloadTool_v3.3.4软件，根据下图进行设置。 选择bin格式的固件文件，固件可以去micropython官网下，点击进入。 地址设置为0x00000，串口根据自己的实际情况选择，小编我的是COM44，波特率115200(必须设置为115200)。 设置完毕，点击start，提示上电同步。这时你需要让板子进入烧写模式。按住板子上的SW2(FLASH)按键不松，同时按一下SW1(RST)按键松开。 界面显示下载中... 同时右边区域显示设备的MAC地址，此时松手只需要等待下载完成即可。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"TPYBoard v202 智能WIFI远控小车.html":{"url":"TPYBoard v202 智能WIFI远控小车.html","title":"TPYBoard v202 智能WIFI远控小车","keywords":"","body":"19.TPYBoard v202 智能WIFI远控小车 设计思路 WIFI是目前最有广泛运用的一项无线网络传输技术，覆盖范围广，可远程。本次实现了远程WIFI控制，不仅可以在家里操作，还可以接入一些云平台，实现远程操控。具体思路如下: 1、TPYBoard v202作为整个小车的核心控制部分，连接L298N电机驱动模块，实现小车的基本方向控制； 2、TPYBoard v202接入网络，开启Socket服务实现web服务器功能； 3、手机接入同一局域网，可通过浏览器访问控制页面，进行小车控制。 前言 之前有过用TPYBoard v102制作的各种各样功能的智能小车，比如自动寻迹、自动避障、手机蓝牙遥控等。想着还缺个WIFI控制的，那就用TPYBoard v202做一个吧。 设计思路 WIFI是目前最有广泛运用的一项无线网络传输技术，覆盖范围广，可远程。本次实现了远程WIFI控制，不仅可以在家里操作，还可以接入一些云平台，实现远程操控。具体思路如下: 1、TPYBoard v202作为整个小车的核心控制部分，连接L298N电机驱动模块，实现小车的基本方向控制； 2、TPYBoard v202接入网络，开启Socket服务实现web服务器功能； 3、手机接入同一局域网，可通过浏览器访问控制页面，进行小车控制。 所需器件 TPYBoard v202开发板 1块 USB数据线（MicroUSB） 1条 L298N电机驱动模块 1个 小车套件包（底板、电机等） 1个 18650电池 2节 18650电池盒 1个 程序源码 TPYBoard v202 源代码(main.py) import socket #导入socket通信库 import machine from machine import Pin g4 = Pin(4,Pin.OUT) g5 = Pin(5,Pin.OUT) g12 = Pin(12,Pin.OUT) g13 = Pin(13,Pin.OUT) def Go(): g4.value(1) g5.value(0) g12.value(1) g13.value(0) def Back(): g4.value(0) g5.value(1) g12.value(0) g13.value(1) def Left(): g4.value(1) g5.value(0) g12.value(0) g13.value(0) def Right(): g4.value(0) g5.value(0) g12.value(1) g13.value(0) def Stop(): g4.value(0) g5.value(0) g12.value(0) g13.value(0) #-----------------------HTTP Server-----------------------# #ap模式下，默认ip地址为192.168.4.1 addr = ('192.168.4.1',80) #定义socket绑定的地址，ip地址为本地，端口为80 s = socket.socket() #创建一个socket对象 s.bind(addr) #绑定地址 s.listen(5) #设置允许连接的客户端数量 print('listening on:', addr) while True: cl, addr = s.accept() #接受客户端的连接请求，cl为此链接创建的一个新的scoket对象，addr客户端地址 print('client connected from:', addr) cl_file = cl.makefile('rwb', 0) #返回与socket对象关联的文件对象。rwb:支持二进制模式的读写操作 0:默认值，不支持缓存 req = b'' while True: line = cl_file.readline() #读取发送过来的数据，直到\\r\\n换行结束 if not line or line == b'\\r\\n': break req += line print(\"Request:\") req=req.decode('utf-8').split('\\r\\n') #http header 解析 req_data=req[0].lstrip().rstrip().replace(' ','').lower() print(req_data) if req_data.find('favicon.ico')>-1: cl.close() continue else: req_data=req_data.replace('get/?','').replace('http/1.1','') index = req_data.find('key=') value = req_data[index+4:index+6].lstrip().rstrip() print('key:',value) if value == 'go': Go() elif value == 'ba': Back() elif value == 'le': Left() elif value == 'ri': Right() else: Stop() with open(\"control.html\", 'r') as f: for line in f: cl.send(line) #cl.send(response) #返回html网页的数据 cl.close() #关闭socket 硬件的连接 TPYBoard v202 L298N电机驱动模块 VIN +5V GND GND G5 IN1 G4 IN2 G13(MO) IN3 G12(MI) IN4 两侧电机 L298N电机驱动模块 车头朝前，右侧电机 OUT1,OUT2 车头朝前，左侧电机 OUT3,OUT4 注：电机不分正负极，怎么接都可以，只不过就是正转和反转的问题。若在调试中电动转动方向不对，你可以修改程序或者将接线调换 L298N电机驱动模块 电池盒 +12V 正极(红线) GND 负极(黑线) 注：可在电池正极与电机驱动之间外接一个按键开关模块，这样可以增加一个总开关功能。 网页效果 演示效果 源码下载 下载源码 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"参考资料.html":{"url":"参考资料.html","title":"参考资料","keywords":"","body":"20.参考资料 TPYBv202 原理图 (52.5KiB PDF) TPYBv202 PCB图 (42.3KiB PDF) TPYBv202 引脚图 (79.5KiB PNG) MCU: STM32F405RGT6 (链接至MCU官网) 加速度传感器: Freescale MMA7660 (800kiB PDF) LDO稳压芯片: Microchip MCP1802 (400kiB PDF) USR-K2: 软件资料 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"PythonBook.html":{"url":"PythonBook.html","title":"PythonBOOK","keywords":"","body":"记录学习Python过程中所看的书籍 bookname:Microsoft零基础上手Python开发 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"第一章开始使用Python.html":{"url":"第一章开始使用Python.html","title":"第一章开始使用Python","keywords":"","body":"第一章 开始使用Python 1.1什么是Python Guido van Rossom：最初的开发者 1.2打造Python的使用场所 Python官网 Python下载 勾选 Add Python XX to PATH 彩蛋： import this © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"第二章Python和编程.html":{"url":"第二章Python和编程.html","title":"第二章Python和编程","keywords":"","body":"第二章 Python 和编程 2.1编程人员的工作 只有你能自行解决问题，此后才能编写程序完成任务 必须让计算机理解你需要干啥 要创建程序，必须拿出一个解决方案，然后将其分解成多个简单步骤，使得计算机可以执行 2.1.1 编程和问题 编程=管道工 在解决问题前，有一个有关问题的严密定义 功能设计规范FDS Functional Design Specification 每次编写程序时，都首先写好周密的规范。即使帮朋友办事，也照写不误，标准丝毫不差，甚至更高。 2.1.2程序用于处理数据 输入文本为黑色，Python输出显示为蓝色，命令提示显示为褐色，错误消息显示为红色 2.2使用Python函数 2.2.1ord函数 ord 即 ordinal value 提供字符对应的数值 2.2.2chr函数 与ord函数作用相反 2.2.3使用bin函数 bin函数返回一个字符串，该字符串是相应数值的二进制表示形式。字符串开头的0b告诉读者，这是数值的二进制表示形式。 2.2.4动手练习 ord('A') 65 ord(' ') 32 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"第三章Python程序结构.html":{"url":"第三章Python程序结构.html","title":"第三章Python程序结构","keywords":"","body":"第三章Python程序结构 3.1print函数 单行程序输出 多行程序输出 给print函数提供一个参数列表 python 自动在显示的每一项之间添加空格 3.2使用Python库 3.2.1random库 random库包含大量函数，下面的是randint函数 返回介于1到6之间的随机数 3.2.2time库 3.2.3sleep函数 我在程序中使用sleep函数，留给用户读取程序显示的内容，可以用在即点即用的程序中，推迟程序的结束时间，让用户看清程序运行过程。 import time print('I will need to think about that..') time.sleep(5) print('The answer is:42') 3.3Python注释 在IDLE中注释显示为红色 3.5添加一些snaps函数 3.5.1添加pygame库 py -m pip install pygame --user 3.5.2snaps函数 1.显示文本 snaps函数display_message的参数是一个文本字符串，该函数在显示器窗口中显示相应的字符串， import snaps snaps.display_meassage('This is smaller text i green on the top left',color=(0,255,0),size=50,horiz='left',vert='top') # 颜色，文本大小，文字对齐（屏幕左侧，右侧，中心对齐），文本对齐（屏幕顶部，底部，中心对齐） 2.显示图像 import snaps snaps.display_image('Housemartins.jpg') # 图像文件名，与程序文件一起，jpg或png snaps.display_meassage('HullRocks',color(255,255,255),size=50,vert='top')# 颜色，文本大小，文字对齐（屏幕左侧，右侧，中心对齐），文本对齐（屏幕顶部，底部，中心对齐） 3.播放音频 import snaps snaps.play_sound('ding.wav') © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"第四章Python使用变量.html":{"url":"第四章Python使用变量.html","title":"第四章Python使用变量","keywords":"","body":"第四章使用变量 4.1Python名称 名称必须以字母或下划线(_)开头，可包含字母、数字、下划线。 区分大小写 命名方法 骆驼式命名法 普通命名法 4.2动手练习 创建Self-Timer(自我控时)生日聚会游戏 # EG4-01 Self Timer import time import random print('Welcome Self Timer') print() print('Everybody stand up') print('Stay standing until you think the time has ended') print('Then sit down.') print('Anyone still standing when the time ends loses.') print('The last person to sit down before the time ended will win') stand_time = random.randint(5,20) # 获得一个随机站立时间值并存储它 print('Stay standing for',) 显示语句中的单引号和双 引号 使用三引号 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"pythonqt5.html":{"url":"pythonqt5.html","title":"PythonQT5","keywords":"","body":"Python-GUI编程 01-什么是GUI编程？ Graphical User Interface，简称 GUI 又称图形化用户接口 会有一个图形化的界面展示给用户，与用户交互 用户只需要鼠标点点点，手指戳戳戳就可以控制 而不是，需要输入代码指令，以及接收枯燥的反馈等等 例如 猜数字 命令行界面版本 GUI界面版本 caishuzi.exe 其他GUI界面举例 所谓的GUI编程，就是编写图形化界面的软件供用户使用 02-在Python中有哪些库可以支持GUI编程？ 介绍文档 https://wiki.python.org/moin/GuiProgramming 官方的标准库 Tkinter IDLE就是使用TKinter实现 其他使用率较高的库 PyQt PySide wxPython PyGUI Kivy Libavg ... 选库标准 表态 没有最好的，只有最适合的 简单好用 功能强大 看需求，有的仅仅需要最简单的界面 文档齐全，方便查看 性能高 稳定性高 生态支持 Qt助手 Qt设计师 ... 跨平台支持 开源免费 基于以上标准对比，最终选择PyQt PyQt是什么？ PyQt是Qt最流行的Python绑定之一 简单理解 使用Python重新实现了一遍Qt的功能 Python的语法简洁, 最终代码量更少 阅读起来更容易理解 在实现的时候, 几乎保持了全部原有的API 学习完PyQt之后, 只要掌握C++语法之后, 就可以快速的接手Qt的使用 本质还是Qt c++写的一个跨平台的GUI开发框架 Qt发展 1991年奇趣科技公司开发的C++ GUI应用程序 2008年奇趣被诺基亚收购，Qt也就变成诺基亚的了 2012年，Qt被Digia收购 2014年发布了Qt5.3正式版，至此，对iOS，Android，WP等平台进行了全面支持 现在提供了开源版本和商业版本 Qt官网 https://www1.qt.io/cn/ Qt功能 xml 网络 多线程 数据库 定位 多媒体 web浏览器 桌面UI 主要讲解这一部分 ... PyQt官网 https://www.riverbankcomputing.com/software/pyqt/intro PyQt的版本 1998年首次发布 PyKDE 后改名PyQt PyQt3 PyQt4 PyQt5 Python对Qt5.x版本的绑定 对Python3支持很好 环境版本选择 Python3 + PyQt5 PyQt优势 简单好用 在同等功能实现的下，使用已经很简单 界面完全可以可视化操作 功能强大 600多个类 种类繁多的控件 跨平台支持 Windows Linux Mac OS iOS Android ... 性能高 Qt使用C++实现 自行领悟 文档齐全 对Qt库Python绑定 除下自己的文档，也几乎可以通用Qt文档 稳定性高 面向对象 信号与槽的机制 界面设计与业务代码完全隔离 生态支持 Qt Designer进行图形界面设计 ui转换成py文件 资源处理 ... 开源免费 PyQt5是双重许可的。开发人员可以在GPL和商业许可之间进行选择 GPL协议 软件版权为开发者本人所有 受国际相关版权法保护 允许其他用户对原作者软件进行复制和发行 也可更改后，发行自己的软件 ... 03-开发环境安装 基本环境 Python3.x解释器环境 pip包管理工具 pipenv虚拟环境管理工具 IDE PyCharm安装 GUI开发环境 全局安装 PyQt5安装 pip install PyQt5 -i https://pypi.douban.com/simple 辅助工具安装 pip install PyQt5-tools -i https://pypi.douban.com/simple 虚拟环境安装 创建虚拟环境（Python3.x版本解释器） cd 项目路径 pipenv --three 修改镜像 清华：https://pypi.tuna.tsinghua.edu.cn/simple Pipfile 激活环境 pipenv shell 安装三方库 pipenv install pyqt5 pipenv install pyqt5-tools 在线文档 http://pyqt.sourceforge.net/Docs/PyQt5/class_reference.html 测试 尝试导入包PyQt5，查看是否有问题 from PyQt5.Qt import * 04-GUI编程应该学什么？ 0. 大致了解你所选择的GUI库 PyQt5 1. 基本程序结构 跑通GUI程序，能够看到一个界面 2. 各种控件的特性和使用 能够知道每个控件都有什么作用，能解决什么需求 知道该怎样去使用这个控件 3. 控件的样式 怎样能把控件的样式搞的好看一点，比如颜色，边框等等 4. 资源的加载 怎样加载资源，展示在GUI控件中 5. 控件的布局 怎样把各个单独的控件摆放的更协调，更美观 6. 事件和信号 怎样能够让用户点击或者做其他交互操作的时候，我们能让程序做事情 7. 动画特效 怎样能够在与用户交互的时候，展示炫酷的动画 8. 界面跳转 从一个窗口，跳转到另外一个窗口 9. 设计工具使用 通过辅助工具来设计界面 10. 额外 网络 多线程 数据库 文件操作 绘图 多媒体 定时器 定位 国际化 ... 05-了解PyQt5库结构 文档 http://pyqt.sourceforge.net/Docs/PyQt5/modules.html 常用模块 QtWidgets 包含了一整套UI元素控件，用于建立符合系统风格的界面 QtGui 涵盖了多种基本图形功能的类 字体 图形 图标 颜色 ... QtCore 涵盖了包的核心的非GUI功能 时间 文件 目录 数据类型 文本流 链接 线程进程 ... QtWebKit 浏览器引擎 QtTest 测试 QtSql 数据库 QtMultimedia QtMultimediaWidgets ... Qt 将基本全部模块中的类综合到一个单一的模块中。 好处 不用关心哪个模块包含哪些类了 坏处 占用内存 06-PyQt5初体验-显示一个窗口 效果图 要求 展示一个500 * 500的窗口 设置窗口标题为“社会我顺哥，人狠话不多” 添加子控件(标签控件)，并显示\"hello word\" 方式 纯手码 07-PyQt5程序基本结构分析 面向过程版本代码 import sys from PyQt5.Qt import * app = QApplication(sys.argv) window = QWidget() window.setWindowTitle(\"社会我顺哥,人狠话不多\") window.resize(500, 500) window.move(400, 200) window.show() sys.exit(app.exec_()) 解释 一个PyQt程序都需要一个应用程序对象 它包含主事件循环，在其中来自窗口系统和其它资源的所有事件被处理和调度。 它也处理应用程序的初始化和结束，并且提供对话管理。 它也处理绝大多数系统范围和应用程序范围的设置。 app.exec_()意思是让程序进入主循环，不要停止 一个没有父对象控件默认不显示，必须要调用show()才可以 一个应用程序中可以显示多个顶级控件 如果一个Widget没有父控件，则认定为是顶级控件（顶级窗口） 有标题栏，可以设置图标，标题 有最大化，最小化，关闭等操作 如果想要一个控件展示在另外一个控件内部，必须要有父子关系 如果两个对象为父子关系，那么父对象显示之后，一般子对象会自动显示 补充 PyCharm活动模板设置 面向对象版本代码 08-控件学习 什么是控件？ 一个程序界面上的各个独立的元素 一块矩形区域 具备不同的功能 用户点击 接收用户输入 展示内容 存放其他控件 ... ... 初识常用控件 按钮 QPushButton QCommandLinkButton QRadioButton QCheckBox 输入控件 纯键盘输入 QLineEdit QTextEdit QPlainTextEdit QKeySequenceEdit 步长调节(QAbstractSpinBox) (键盘+鼠标) QDateTimeEdit QDateEdit QTimeEdit QSpinBox QDoubleSpinBox 组合框(下拉选择输入) QComboBox QFontComboBox 滑块(QAbstractSlider)(鼠标) QDial QSlider QScrollBar 橡皮筋选中 QRubberBand 对话框(QDialog) QColorDialog QFileDialog QFontDialog QInputDialog 日期 QCalendarWidget 展示控件 QLabel 效果图 普通文本 数字 富文本 QLabel-超链接 图片 QLabel-动画 QLCDNumber QProgressBar 对话框(QDialog) QMessageBox 效果图 QErrorMessage QProgressDialog 容器控件 QToolBox QDialogButtonBox 效果图 QGroupBox 效果图 QMdiSubWindow QMdiArea和QMdiSubWindow 结构控件 QMainWindow 效果图 相关控件 QMenuBar 相关控件 QMenu QToolBar 效果图 相关控件 QToolButton QStatusBar 效果图 QTabwidget 相关控件 QTabBar QStackedWidget QSplitter 相关控件 QSplitterHandle 效果图 QDockWidget 滚动控件 QAbstractScrollArea QTextBrowser QScrollArea QAbstractItemView QColumnView QHeaderView 效果图 QListView QListWidget QUndoView QTableView 效果图 QTableWidget QTreeView QTreeWidget QMdiarea QGraphicsView 辅助控件 QFocusFrame 效果图 QSizeGrip 效果图 QDesktopWidget 效果图 其他 向导/打印(QDialog) QWizard 相关控件 QWizardPage QAbstractPrintDialog QPrintDialog 效果图 QPrintPreviewDialog 效果图 相关控件 QPrintPreviewWidget QPageSetupDialog 效果图 欢迎界面QSplashScreen QSplashScreen 功能性控件 QVideoWidget 需要下载解码器 http://www.codecguide.com/configuration_tips.htm?version=1430 QCameraViewfinder 效果图 QWebEngineView 效果图 不同的控件有 相同的共性 名字 矩形区域 位置 大小 可以设置样式 ... 不同的特性 展示内容 接收输入 用户交互 容器 框架 ... 类继承图(了解) 基类(共性) QObject QWidget QAbstractButton QPushButton QFrame QAbstractScrollArea QAbstractItemView QListView QTableView QTreeView QTextEdit QAbstractSpinBox QAbstractSlider QComboBox QDialog 子类(特性) 基础控件 按钮 QPushButton 描述 用来给用户点击, 来完成某种动作的控件 一般是矩形 例如 登录按钮 注册按钮 关闭按钮 是 否 ... 继承 QAbstractButton 功能作用 创建按钮控件 QPushButton() 创建一个无父控件的按钮控件 QPushButton(parent) 创建控件的同时, 设置父控件 QPushButton(text, parent) 创建控件的同时, 设置提示文本和父控件 QPushButton(icon, text, parent) 创建控件的同时, 设置图标, 提示文本和父控件 菜单 API setMenu(QMenu) 设置菜单 menu() 获取菜单 showMenu() 展示菜单 应用场景 可以设置点击按钮是弹出的菜单， 供用户选择 案例 测试以上API 补充 QMenu 添加子菜单 addMenu(QMenu) 添加分割线 addSeparator() 添加行为动作 addAction(QAction) QMenu控件设置 setTitle(str) setIcon(QIcon) QAction设置 setText(str) setIcon(QIcon) 信号 triggered 边框是否保持扁平 API setFlat(bool) 默认值为False 设置了此属性，则除非按下按钮，否则大多数样式都不会绘制按钮背景 isFlat() 获取当前按钮边框是否扁平 应用场景 设置按钮扁平化风格 案例 测试以上API 默认处理 API setAutoDefault(bool) 设置为自动默认按钮 在某些GUI样式中，默认按钮被绘制，其周围有一个额外的框架，最多3个像素或更多。 Qt会自动在自动默认按钮周围保留此空间，即自动默认按钮可能会有稍大的提示 对于具有QDialog父级的按钮，此属性的默认值为true ; 否则默认为false。 autoDefault() setDefault(bool) isDefault() 应用场景 一般是在对话框中使用 案例 测试以上API 信号 都是继承下来的 QAbstractButton pressed() 鼠标按下信号 released() 鼠标释放 控件内松开鼠标 鼠标移出控件范围后松开 clicked(checked = false) 控件内按下+控件内释放 toggled(bool checked) 切换信号(一般在单选框或者复选框中使用) QWidget windowTitleChanged(QString) 窗口标题改变信号 windowIconChanged(QIcon) 窗口图标改变信号 customContextMenuRequested(QPoint) 自定义上下文菜单请求信号 setContextMenuPolicy(Qt.CustomContextMenu) Qt.DefaultContextMenu 调用对象方法contextMenuEvent() Qt.CustomContextMenu 发射信号 QCommandLinkButton 描述 命令链接是Windows Vista引入的新控件 它的用途类似于单选按钮的用途，因为它用于在一组互斥选项之间进行选择 命令链接按钮不应单独使用，而应作为向导和对话框中单选按钮的替代选项 外观通常类似于平面按钮的外观，但除了普通按钮文本之外，它还允许描述性文本 继承 QPushButton 功能作用 创建命令链接按钮 QCommandLinkBut​​ton(parent) QCommandLinkBut​​ton(text, parent) QCommandLinkBut​​ton(text, description ,parent) 描述设置 API setDescription(str) description() 应用场景 设置命令链接按钮的描述文本 案例 测试以上API 信号 看他老爸去 QToolButton 描述 提供了一个快速访问按钮 通常是在工具栏内部使用 工具按钮通常不显示文本标签，而是显示图标 例如 继承 QAbstractButton 功能作用 创建按钮 QToolButton(parent: QWidget = None) (继承)设置文本,图标,工具提示 API setText(str) setIcon(QIcon) setIconSize(QSize) setToolTip(str) 注意 如果文本和图标同时设置, 则默认只展示图标 案例 测试以上API 按钮样式风格 API setToolButtonStyle(Qt.ToolButtonStyle) 风格取值 Qt.ToolButtonIconOnly 仅显示图标 Qt.ToolButtonTextOnly 仅显示文字 Qt.ToolButtonTextBesideIcon 文本显示在图标旁边 Qt.ToolButtonTextUnderIcon 文本显示在图标下方 Qt.ToolButtonFollowStyle 遵循风格 toolButtonStyle() 应用场景 设置按钮的图标和文字组合 案例 测试以上API 设置箭头 API setArrowType(Qt.ArrowType) Qt.ArrowType Qt.NoArrow 无箭头 Qt.UpArrow 向上箭头 Qt.DownArrow 向下箭头 Qt.LeftArrow 向左箭头 Qt.RightArrow 向右箭头 arrowType() 应用场景 将按钮变成一个具备特殊箭头图标的按钮 案例 测试以上API 自动提升 API setAutoRaise(bool) autoRaise() 应用场景 在自动提升模式下，该按钮仅在鼠标指向时才会绘制3D帧 在工具栏(QToolBar)中, 默认就是自动提升 案例 测试以上API 菜单 API setMenu(QMenu) menu() 应用场景 通过菜单展示更多选项 案例 测试以上API 菜单弹出模式 API setPopupMode(QToolButton.ToolButtonPopupMode) QToolButton.ToolButtonPopupMode QToolButton.DelayedPopup 鼠标按住一会才显示 类似于浏览器后退按钮 QToolButton.MenuButtonPopup 有一个专门的指示箭头 点击箭头才显示 QToolButton.InstantPopup 点了按钮就显示 点击信号不会发射 popupMode() 应用场景 设置菜单弹出的触发方式 案例 测试以上API 信号 triggered(QAction *action) 当点击某个action时触发, 并会将action传递出来 小技巧 QAction对象可以通过 setData(Any) 绑定数据 data() 获取数据 其他都是继承的 QRadioButton 描述 一般用于给用户提供若干选项中的单选操作 比如 性别 男 女 答案 是 否 ... 当选中一个时, 会自动取消上一个 此按钮左侧会有一个圆圈图标, 用于标识用户的选中状态 继承 QAbstractButton 功能作用 创建单选按钮 QRadioButton(parent) QRadioButton(text, parent) 常用继承父类操作 图标 setIcon(QIcon) 快捷键 文本加& setShortcut() 信号 均继承自父类 常用信号为 toggled(bool) QCheckBox 描述 一般用于给用户提供若干选项中的多选操作 比如 兴趣爱好 Python C++ ... 点外卖加配料 酱油 辣椒 醋 ... 可以都选, 可以都不选, 可以选部分 左侧会有一个方框图标, 标识用户的选中状态 继承 QAbstractButton 功能作用 创建复选框按钮 QCheckBox(parent=None) QCheckBox(text, parent=None) 常用继承父类操作 图标 setIcon(QIcon) 快捷键 文本加& setShortcut() 设置是否三态 API setTristate(bool=True) isTristate() 应用场景 是否支持复选框展示三种状态 设置复选框状态 API setCheckState(Qt.CheckState) checkState() 应用场景 想给用户多一种选择状态 补充 状态 Qt.Unchecked 该项目未选中 Qt.PartiallyChecked 部分选中 Qt::Checked 真的被选中 信号 stateChanged(int state) 选中或清除选中时, 发射此信号 其他都继承 补充 QButtonGroup 描述 提供 一个抽象的按钮容器, 可以将多个按钮划分为一组 不具备可视化的效果 一般放的都是可以被检查的按钮 继承 QObject 功能 创建按钮组 QButtonGroup(parent) 添加按钮 API addButton(QAbstractButton, id = -1) 如果id为-1，则将为该按钮分配一个id。自动分配的ID保证为负数，从-2开始。 如果要分配自己的ID，请使用正值以避免冲突 应用场景 向按钮组中添加按钮, 并选择性设置ID 查看按钮 API buttons() 查看所有按钮组中的按钮 button(ID) 根据ID获取对应按钮, 没有则返回None checkedButton() 获取选中的那个按钮 应用场景 获取指定条件的按钮 移除按钮 API removeButton(QAbstractButton) 应用场景 移除指定按钮 注意 不是从界面上移除 是从抽象关系上移除 绑定和获取ID API setId(QAbstractButton，int) id(QAbstractButton) 指定按钮对应的ID 如果不存在此按钮，则返回-1 checkedId() 选中的ID 如果没有选中按钮则返回-1 应用场景 设置ID, 方便识别用户选项 独占设置 API setExclusive(bool) exclusive() 应用场景 统一设置按钮组中的按钮是否是独占(选择互斥) 信号 buttonClicked(int/QAbstractButton) 当按钮组中的按钮被点击时, 发射此信号 buttonPressed(int/QAbstractButton) 当按钮组中的按钮被按下时, 发射此信号 buttonReleased(int/QAbstractButton) 当按钮组中的按钮被释放时, 发射此信号 buttonToggled(QAbstractButton/int, bool) 当按钮组中的按钮被切换状态时, 发射此信号 重点注意 如果一个对象向外界提供的信号名称一样, 但参数不一样 外界在使用信号时, 可以使用如下格式进行选择 signal_name[type] signal_name 信号名称 type 参数类型 输入控件 纯键盘文本输入 QLineEdit 描述 是一个单行文本编辑器 允许用户输入和编辑单行纯文本 自带一组编辑功能 编辑功能 撤消 重做 剪切 粘贴 拖放 继承 QWidget 功能作用 控件的创建 QLineEdit(parent: QWidget = None) QLineEdit(str, parent: QWidget = None) 文本的设置和获取 API setText(str) 设置内容文本 insert(newText) 在光标处插入文本 text() 获取真实内容文本 displayText() 获取用户能看到的内容文本 应用场景 通过代码来控制输入文本内容 案例 创建一个窗口, 添加两个文本框一个按钮 要求 点击按钮后 将文本框A内输入的内容 复制到文本框B中 输出模式 API setEchoMode(QLineEdit.EchoMode) QLineEdit.EchoMode NoEcho = 1 不输出 Normal = 0 正常输出 Password = 2 密文形式 PasswordEchoOnEdit = 3 编辑时明文, 结束后密文 echoMode() -> QLineEdit.EchoMode 获取输出模式 应用场景 设置输出模式, 来适应不同的应用场景 明文 密文 保护用户隐私 不输出 案例 模拟用户登录案例 创建一个窗口, 添加两个文本框一个按钮 要求 一个用作账号 另外一个用作密码 点击登录按钮后, 获取账号和密码信息 进行比对账号密码信息 正确账号 sz 正确密码 itlike 如果账号错误, 则清空账号框和密码框 密码错误则清空密码框 占位提示字符串 API setPlaceholderText(notice_str) placeholderText() 应用场景 在用户输入文本内容之前, 给用户的提示语句 文本框内容 空 显示提示文本 不空 隐藏提示文本 案例 完善上述案例 添加账号和密码输入提示 清空按钮显示 API setClearButtonEnabled(bool) isClearButtonEnabled() -> bool 应用场景 用作快速清空文本框内容 案例 完善上述案例 为密码文本框添加清空按钮 添加操作行为 API addAction(QAction, QLineEdit.ActionPosition) QLineEdit.ActionPosition QLineEdit.LeadingPosition 搁前面 QLineEdit.TrailingPosition 搁后面 addAction(QIcon, QLineEdit.ActionPosition) -> QAction 应用场景 为文本框添加附加的行为操作 案例 完善上述案例 为密码文本框添加明文和密文切换按钮 图片素材 自动补全 API setCompleter(QCompleter) 设置完成器 completer() -> QCompleter 应用场景 根据用户已输入的字符串, 快速联想补全 案例 完善上述案例 为账号文本框, 设置补全候选项 Sz shehui wangzha 输入限制 API 内容长度限制 setMaxLength(int) 设置限制输入的长度 maxLength() 获取输入长度 只读限制 setReadOnly(bool) isReadOnly() 规则验证 setValidator(QValidator) 设置验证器 setInputMask(mask_str) 掩码验证 判定输入文本是否通过验证 hasAcceptableInput() 应用场景 限制用户在文本框中输入的内容 案例 测试以上API 补充 QValidator 描述 验证器 用于验证用户输入数据的合法性 如果一个输入框设置了验证器 到时用户在文本框中输入内容时 首先会将内容传递给验证器进行验证 validate(self, input_text, pos) return (QValidator.Acceptable, input_text, pos) 验证通过 return (QValidator.Intermediate, input_text, pos) 暂不作判定是否通过验证 return (QValidator.Invalid, input_text, pos) 验证不通过 如果输入框结束输入后, 上述的验证状态并非有效, 则会调用修复方法 fixup(self, input_text) return 修正后文本 是一个抽象类, 使用前需要进行子类化操作 自定义子类 系统提供子类 QIntValidator(bottom, top, parent) 限制整型数据范围 QDoubleValidator 浮点类型数据限制范围 经测试, 无效 需要手动实现 QRegExpValidator 通过正则表达式限定 基本使用 第一步 子类化此类 第二步 实现 validate(self, input_text, pos) return (QValidator.Acceptable, input_text, pos) 验证通过 return (QValidator.Intermediate, input_text, pos) 暂不作判定是否通过验证 return (QValidator.Invalid, input_text, pos) 验证不通过 fixup(self, input_text) return 修正后文本 掩码含义 掩码可以指定固定位置的固定数据类型, 达到一个格式上的限制 例如 座机号码 四位区号-七位电话 IP地址 XXX.XXX.XXX.XXX 掩码由一串掩码字符和分隔符组成 + 可选的分号; 和 空白占位字符 掩码字符含义 是否被编辑 API isModified() setModified(bool) 应用场景 标识文本内容是否被修改 案例 测试以上API 光标控制 API cursorBackward(bool mark，int steps = 1) 向后(左)移动steps个字符 mark: True 带选中效果 mark: False 不带选中效果 cursorForward(bool mark，int steps = 1) 向前(右)移动steps个字符 mark: True 带选中效果 mark: False 不带选中效果 cursorWordBackward(bool mark) 向后(左)移动一个单词长度 mark: True 带选中效果 mark: False 不带选中效果 cursorWordForward(bool mark) 向前(右)移动一个单词长度 mark: True 带选中效果 mark: False 不带选中效果 home(bool) 移动到行首 True 带选中 False 不带选中 end(bool) 移动到行尾 True 带选中 False 不带选中 setCursorPosition(int) 设置光标位置 cursorPosition() 获取光标位置 cursorPositionAt(const QPoint＆ pos) 获取指定坐标位置对应文本光标位置 应用场景 控制光标, 以及文本选中操作 案例 测试以上API 文本边距设置 API getTextMargins() setTextMargins(int left，int top，int right，int bottom) 应用场景 设置文本内容边距 案例 测试以上API 对齐方式 API setAlignment(Qt.Alignment) 设置输入文本的对齐方式 Qt.Alignment 水平 Qt.AlignLeft Qt.AlignRight Qt.AlignHCenter Qt.AlignJustify 此处同左对齐 垂直 Qt.AlignTop Qt.AlignBottom Qt.AlignVCenter Qt.AlignBaseline Qt.AlignCenter 等同于 Qt.AlignHCenter | Qt.AlignVCenter 垂直和水平都居中 alignment() -> Qt.Alignment 应用场景 设置用户输入的内容文本对齐方式 案例 测试上述API 常用编辑功能 API 退格 backspace() 删除选中文本 如果有 或 删除光标左侧一个字符 删除 del_() 删除选中文本 如果有 或 删除光标右侧的一个字符 清空 clear() 删除所有文本框内容 复制 copy() 剪切 cut() 粘贴 paste() 撤消 isUndoAvailable() undo() 重做 isRedoAvailable() redo() 拖放 setDragEnabled(bool) 设置选中文本后是否可以拖拽 文本选中 setSelection(start_pos, length) 选中指定区间的文本 selectAll() 选中所有文本 deselect() 取消选中已选择文本 hasSelectedText() 是否有选中文本 selectedText() -> str 获取选中的文本 selectionStart() -> int 选中的开始位置 selectionEnd() -> int 选中的结束位置 selectionLength() -> int 选中的长度 应用场景 编辑用户输入的文本 案例 测试上述API 信号 textEdited( text) 文本编辑时发射的信号 textChanged(text) 文本框文本发生改变时发出的信号 returnPressed() 按下回车键时发出的信号 editingFinished() 结束编辑时发出的信号 cursorPositionChanged(int oldPos，int newPos) 光标位置发生改变时发出的信号 selectionChanged() 选中的文本发生改变时发出的信号 QTextEdit 描述 是一个高级的WYSIWYG(What You See Is What You Get 所见即所得)查看器/编辑器，支持使用HTML样式标签的富文本格式。 支持的HTML4标签子集 https://doc.qt.io/qt-5/richtext-html-subset.html 如果不够, 可以考虑使用WebKit 它经过优化，可以处理大型文档并快速响应用户输入。 适用于段落和字符 如果文本太大而无法在文本编辑的视口中查看，则会出现滚动条 文本编辑可以加载纯文本和富文本文件 以显示图像，列表和表格 继承 QAbstractScrollArea 功能作用 占位提示文本 API setPlaceholderText(str) placeholderText() -> str 应用场景 在文本框内部内容为空时, 给用户的文本提示信息 案例 测试以上API 内容设置 API 普通文本 setPlainText(str) insertPlainText(str) toPlainText() -> str HTML setHtml(str) insertHtml(str) toHtml() -> str 设置文本(自动判定) setText(str) 追加文本 append(str) 清空 clear() 文本光标 理论基础 通过文本光标, 可以操作编辑 文本文档 对象 概念 整个文本编辑器, 其实就是为编辑 这个文本文档 提供了一个可视化的界面 简单理解, 可以比喻成 一个doc文档, 使用word软件打开了这个文档, 你可以随意编辑 获取文本文档的方法 API te.document() -> QTextDocument 补充 QTextDocument 描述 保存带格式的文本文档 为样式化文本和各种类型的文档元素提供支持 框架 文本块 列表 表格 图像 ... 是结构化富文本文档的容器 一个空的文档包含一个根框架，这个框架包含一个空的文本块 当需要进行文档结构导航时，有时候可以从根框架开始。 因为根框架提供了访问整个文档结构的能力 文本属性在字符级别和块级别定义 在字符级别可以指定字体、颜色和大小 在块级别可以指定更高一级的行为，例如文本流方向、对齐方式和背景色 继承结构图 QTextDocument QTextObject QTextBlockGroup QTextList QTextFrame QTextTable QTextBlock QTextFormat QTextBlockFormat QTextCharFormat QTextImageFormat QTextTableCellFormat QTextFrameFormat QTextTableFormat QTextListFormat textCursor() -> QTextCursor 常用功能 添加内容 API 插入文本 insertText(str) 插入文本(普通文本) insertText(QString text, QTextCharFormat format) 插入文本, 带格式 QTextCharFormat 针对于部分字符的格式描述 insertHtml(html_str) 插入HTML 字符串 插入图片 insertImage(QTextImageFormat) QTextImageFormat tf.setName(\"xxx.png\") tf.setWidth(20) tf.setHeight(20) insertImage(QTextImageFormat, QTextFrameFormat.Position) insertImage(name_str) insertImage(QImage, name_str=None) 插入句子 insertFragment(QTextDocumentFragment ) QTextDocumentFragment 构建对象 fromHtml(html_str) fromPlainText(str) 插入列表 insertList(QTextListFormat) -> QTextList 在当前位置插入一个新块，并使其成为具有给定格式的新创建列表的第一个列表项。返回创建的列表 insertList(QTextListFormat.Style) -> QTextList 在当前位置插入一个新块，并使其成为具有给定格式的新创建列表的第一个列表项。返回创建的列表 createList(QTextListFormat ) -> QTextList 创建并返回具有给定格式的新列表，并使当前段落的光标位于第一个列表项中 createList(QTextListFormat.style ) -> QTextList 创建并返回具有给定格式的新列表，并使当前段落的光标位于第一个列表项中 补充 QTextListFormat setIndent(int) setNumberPrefix(str) setNumberSuffix(str) setStyle(QTextListFormat_Style) QTextListFormat.Style QTextListFormat.ListDisc 一个圆圈 QTextListFormat.ListCircle 一个空的圆圈 QTextListFormat.ListSquare 一个方块 QTextListFormat.ListDecimal 十进制值按升序排列 QTextListFormat.ListLowerAlpha 小写拉丁字符按字母顺序排列 QTextListFormat.ListUpperAlpha 大写拉丁字符按字母顺序排列 QTextListFormat.ListLowerRoman 小写罗马数字（仅支持最多4999项） QTextListFormat.ListUpperRoman 大写罗马数字（仅支持最多4999项） 插入表格 insertTable(int rows, int columns) -> QTextTable insertTable(int rows, int columns, QTextTableFormat) -> QTextTable 补充 QTextTableFormat setAlignment(self, Union, Qt_Alignment=None, Qt_AlignmentFlag=None) 对齐方式 setCellPadding(self, p_float) 内边距 setCellSpacing(self, p_float) 外边距 setColumnWidthConstraints(self, Iterable, QTextLength=None) 设置列宽 边距图示 插入文本块 insertBlock() 插入一个空的文本块 insertBlock(QTextBlockFormat) 插入文本块的同时, 设置文本块格式 insertBlock(QTextBlockFormat, QTextCharFormat ) 插入文本块的同时, 设置文本块格式和文本字符格式 插入框架 insertFrame(QTextFrameFormat) -> QTextFrame 应用场景 插入指定格式的内容元素 案例 测试以上API 设置和合并格式 API setBlockCharFormat(QTextCharFormat) 设置要格式化的当前块（或选择中包含的所有块）的块char 格式 setBlockFormat(QTextBlockFormat) 设置当前块的块格式（或选择中包含的所有块）以进行格式化 setCharFormat(QTextCharFormat) 将光标的当前字符格式设置为给定格式。如果光标有选择，则给定格式应用于当前选择 mergeBlockCharFormat(QTextCharFormat) 合并当前块的char格式 mergeBlockFormat(QTextBlockFormat) 合并当前块的格式 mergeCharFormat(QTextCharFormat) 合并当前字符格式 应用场景 设置和合并格式 案例 测试以上API 获取内容和格式相关 API block() -> QTextBlock 获取光标所在的文本块 blockFormat() -> QTextBlockFormat 获取光标所在的文本块格式 blockCharFormat() -> QTextCharFormat 获取光标所在的文本块字符格式 blockNumber() -> int 获取光标所在的文本块编号 charFormat() -> QTextCharFormat 获取文本字符格式 currentFrame() -> QTextFrame 获取当前所在的框架 currentList() -> QTextList 获取当前所在的文本列表 currentTable() -> QTextTable 获取当前的表格 应用场景 通过文本光标获取当前所在的内容和格式信息 案例 测试以上API 文本选中和清空 API 选中 setPosition(int pos, QTextCursor.MoveMode=MoveAnchor) 设置光标位置 需要反向设置回去 movePosition(QTextCursor.MoveOperation, QTextCursor.MoveMode=MoveAnchor, int n = 1) 移动指定长度后, 参照移动选项和模式确定最终位置以及是否选中文本 需要反向设置 select(QTextCursor.SelectionType) 需要反向设置 选中内容获取 selectedText() -> str selection() -> QTextDocumentFragment selectedTableCells() -> (int firstRow, int numRows, int firstColumn, int numColumns) 选中的位置获取 selectionStart() -> int selectionEnd() -> int 清空和判定 clearSelection() 取消文本的选中 需要反向设置 hasSelection() -> bool 是否有选中文本 选中文本的移除 removeSelectedText() 移除选中的文本 补充 QTextCursor.MoveMode QTextCursor.MoveAnchor 将锚点移动到与光标本身相同的位置。 QTextCursor.KeepAnchor 将锚固定在原处。 QTextCursor.MoveOperation QTextCursor.NoMove 将光标保持在原位 QTextCursor.Start 移至文档的开头。 QTextCursor.StartOfLine 移动到当前行的开头。 QTextCursor.StartOfBlock 移动到当前块的开头。 QTextCursor.StartOfWord 移动到当前单词的开头。 QTextCursor.PreviousBlock 移动到上一个块的开头。 QTextCursor.PreviousCharacter 移至上一个字符。 QTextCursor.PreviousWord 移到上一个单词的开头。 QTextCursor.Up 向上移动一行。 QTextCursor.Left 向左移动一个字符。 QTextCursor.WordLeft 向左移动一个单词。 QTextCursor.End 移到文档的末尾。 QTextCursor.EndOfLine 移动到当前行的末尾。 QTextCursor.EndOfWord 移到当前单词的末尾。 QTextCursor.EndOfBlock 移动到当前块的末尾。 QTextCursor.NextBlock 移动到下一个块的开头。 QTextCursor.NextCharacter 移动到下一个角色。 QTextCursor.NextWord 转到下一个单词。 QTextCursor.Down 向下移动一行。 QTextCursor.Right 向右移动一个角色。 QTextCursor.WordRight 向右移动一个单词。 QTextCursor.NextCell 移动到当前表中下一个表格单元格的开头。如果当前单元格是行中的最后一个单元格，则光标将移动到下一行中的第一个单元格。 QTextCursor.PreviousCell 移动到当前表内的上一个表格单元格的开头。如果当前单元格是行中的第一个单元格，则光标将移动到上一行中的最后一个单元格。 QTextCursor.NextRow 移动到当前表中下一行的第一个新单元格。 QTextCursor.PreviousRow 移动到当前表中上一行的最后一个单元格。 QTextCursor.SelectionType QTextCursor.Document 选择整个文档。 QTextCursor.BlockUnderCursor 选择光标下的文本块。 QTextCursor.LineUnderCursor 选择光标下的文本行。 QTextCursor.WordUnderCursor 选择光标下的单词。如果光标未定位在可选字符串中，则不选择任何文本。 应用场景 通过文本光标对象来操作输入框内容 案例 测试以上API 删除内容 API deleteChar() 如果没有选中文本, 删除文本光标后一个字符 如果有选中文本, 则删除选中文本 deletePreviousChar() 如果没有选中文本, 删除文本光标前一个字符 如果有选中文本, 则删除选中文本 应用场景 删除单个字符 案例 测试以上API 位置相关 API atBlockEnd() 是否在文本块末尾 atBlockStart() 是否在文本块开始 atEnd() 是否在文档末尾 atStart() 是否在文档开始 columnNumber() -> int 在第几列 position() 光标位置 positionInBlock() 在文本块中的位置 应用场景 获取和判定光标的位置 案例 测试以上API 开始和结束编辑标识 API beginEditBlock() endEditBlock() 应用场景 指示文档上的编辑操作块的开始， 该操作应从撤消/重做的角度显示为单个操作。 案例 测试以上API 应用场景 设置与获取文本信息 案例 测试以上API 自动格式化 API setAutoFormatting(QTextEdit.AutoFormatting) QTextEdit.AutoFormatting QTextEdit.AutoNone 不要做任何自动格式化。 QTextEdit.AutoBulletList 自动创建项目符号列表（例如，当用户在最左侧列中输入星号（'*'）时，或在现有列表项中按Enter键。 QTextEdit.AutoAll 应用所有自动格式。目前仅支持自动项目符号列表。 autoFormatting() -> QTextEdit.AutoFormatting 应用场景 输入一些特定字符, 会转换成为对应的效果 案例 测试以上API 软换行模式 API setLineWrapMode(QTextEdit.LineWrapMode) 设置软换行模式 lineWrapMode() -> QTextEdit.LineWrapMode 获取软换行模式 setWordWrapMode(self, QTextOption.WrapMode) 设置单词换行模式 wordWrapMode(self) -> QTextOption.WrapMode 获取单词换行模式 补充 QTextEdit.LineWrapMode QTextEdit.NoWrap 没有软换行, 超过宽度后, 会产生水平滚动条 QTextEdit.WidgetWidth 以控件的宽度为限制 但会保持单词的完整性 QTextEdit.FixedPixelWidth 填充像素宽度 配合 setLineWrapColumnOrWidth(int) lineWrapColumnOrWidth() -> int QTextEdit.FixedColumnWidth 填充列的宽度 配合 setLineWrapColumnOrWidth(int) lineWrapColumnOrWidth() -> int QTextOption.WrapMode QTextOption.NoWrap 文本根本没有包装。 QTextOption.WordWrap 保持单词完整性 QTextOption.ManualWrap 与QTextOption.NoWrap相同 QTextOption.WrapAnywhere 宽度够了之后, 随意在任何位置换行 QTextOption.WrapAtWordBoundaryOrAnywhere 尽可能赶在单词的边界, 否则就在任意位置换行 应用场景 设置当用户输入内容过多时, 是否进行软换行, 以及如何进行软换行 案例 测试以上API 覆盖模式 API setOverwriteMode(bool) overwriteMode() -> bool 应用场景 切换覆盖模式, 修改文本内容 案例 测试以上API 光标设置 API 光标宽度 setCursorWidth(int) cursorWidth() 光标矩形 cursorRect() -> QRect 应用场景 一般是结合覆盖模式来做, 标识光标的宽度, 给用户以提醒 案例 测试下, 以后有需求直接用 对齐方式 API setAlignment(Qt.Alignment) 常用有效对齐是 Qt.AlignLeft Qt.AlignRight Qt.AlignCenter alignment() -> Qt.Alignment 应用场景 设置当前段落的对齐方式 案例 测试以上API 字体格式 API 字体家族 setFontFamily(family_str) fontFamily() 小技巧 QFontDialog.getFont() 查看可用的字体 字体样式 字体粗细 setFontWeight(int) QFont.Thin QFont.ExtraLight QFont.Light QFont.Normal QFont.Medium QFont.DemiBold QFont.Bold QFont.ExtraBold QFont.Black fontWeight() 字体斜体 setFontItalic(bool) fontItalic() 字体尺寸 setFontPointSize(float) fontPointSize() 字体效果 字体下划线 setFontUnderline(bool) fontUnderline() 统一设置QFont setCurrentFont(QFont) currentFont() -> QFont 应用场景 设置当前文本框内容字体样式 案例 测试以上API 颜色设置 API 背景颜色 setTextBackgroundColor(QColor) 将当前格式的文本背景颜色设置为指定颜色 textBackgroundColor() -> QColor 文本颜色 setTextColor(QColor) 将当前格式的文本颜色设置为指定颜色 textColor() -> QColor 应用场景 修改文本前景色以及背景色 案例 测试以上API 当前的字符格式 API setCurrentCharFormat(QTextCharFormat) mergeCurrentCharFormat(QTextCharFormat) currentCharFormat() -> QTextCharFormat 应用场景 针对于部分字符, 设置特定的格式 将新文本插入格式时使用的char格式。 如果编辑器有选择的文本内容，则char格式直接应用于选择 案例 测试以上API 补充 QTextCharFormat 描述 提供了一种字符格式信息 文档中文本的字符格式指定文本的可视属性，以及有关其在超文本文档中的角色的信息 常用功能作用 字体 统一设置 setFont(QFont) font() -> QFont 字体家族 setFontFamily(family_str) fontFamily() -> str 字体大小 setFontPointSize(float) fontPointSize() -> float 字体粗细 setFontWeight(int) fontWeight() -> int 字体上划线 setFontOverline(bool) fontOverline() -> bool 字体中划线 setFontStrikeOut(bool) fontStrikeOut() -> bool 字体下划线 setFontUnderline(bool) fontUnderline() -> bool 字体大小写 setFontCapitalization(QFont.Capitalization) fontCapitalization() -> QFont.Capitalization QFont.MixedCase 这是正常的文本呈现选项，不应用大写更改。 QFont.AllUppercase 这会改变要以全大写类型呈现的文本。 QFont.AllLowercase 这会改变要以全小写类型呈现的文本。 QFont.SmallCaps 这会改变要以小型大写字母呈现的文本。 QFont.Capitalize 这会将要呈现的文本更改为每个单词的第一个字符作为大写字符。 颜色 setForeground(QColor(100, 200, 150)) 超链接 setAnchorHref(\"http://www.itlike.com\") anchorHref() -> str ... 常用编辑操作 API copy() paste() canPaste() -> bool setUndoRedoEnabled(bool) redo() undo() selectAll() find(str, options: Union[QTextDocument.FindFlags, QTextDocument.FindFlag] = QTextDocument.FindFlags()) -> bool QTextDocument.FindBackward 向后搜索而不是向前搜索。 QTextDocument.FindCaseSensitively 默认情况下，查找工作区不区分大小写。 指定此选项会将行为更改为区分大小写的查找操作。 QTextDocument.FindWholeWords 使查找匹配仅完整的单词。 应用场景 常用内容文档编辑操作 滚动 scrollToAnchor(p_str) 注意 锚点设置 xxx 只读设置 setReadOnly(self, bool) isReadOnly() -> bool tab控制 setTabChangesFocus(bool) 控制Tab键位的功能, 是否是改变焦点 默认是False setTabStopDistance(p_float) 制表位的距离 默认80(像素) setTabStopWidth(p_int) 经测试, 同上 tabStopDistance(self) -> float 获取距离 tabStopWidth() -> int 获取宽度 锚点获取 API anchorAt(QPoint) -> str 应用场景 返回位置pos处的锚点的引用，如果该点处不存在锚点，则返回空字符串 案例 单击超链接后, 打开对应的网页 补充 QDesktopServices.openUrl(QUrl(urlString)) 打开指定链接地址 信号 textChanged() 文本内容发生改变时, 发射的信号 selectionChanged() 选中内容发生改变时, 发射的信号 cursorPositionChanged() 光标位置发生改变时, 发射的信号 currentCharFormatChanged(QTextCharFormat) 当前额字符格式发生改变时, 发射的信号 copyAvailable(bool yes) 复制可用时 redoAvailable(bool available) 重做可用时 undoAvailable(bool available) 撤销可用时 QPlainTextEdit 描述 QPlainText和QTextEdit大致功能实现差不多 适用于段落和字符 段落是一个格式化的字符串,为了适应控件的宽度, 会自动换行 默认情况下，在读取纯文本时，一个换行符表示一个段落。 文档由零个或多个段落组成。段落由硬线断开分隔。 段落中的每个字符都有自己的属性，例如字体和颜色。 内容的编辑 文本的选择由QTextCursor类处理，该类提供创建选择，检索文本内容或删除选择的功能 QPlainTextEdit包含一个QTextDocument对象，可以使用document（）方法检索该对象 但针对纯文本处理进行了优化 与QTextEdit的差异 QPlainTextEdit是一个简略版本的类 使用QTextEdit和QTextDocument作为背后实现的技术支撑 它的性能优于QTextEdit, 主要是因为在文本文档中使用QPlainTextDocumentLayout简化文本布局 纯文本文档布局不支持表格或嵌入框架，并使用逐行逐段滚动方法替换像素精确高度计算。 继承 QAbstractScrollArea 功能作用 构造函数 QPlainTextEdit(parent: QWidget = None) QPlainTextEdit(str, parent: QWidget = None) 占位提示文本 API setPlaceholderText(str) placeholderText() -> str 应用场景 在文本框内部内容为空时, 给用户的文本提示信息 案例 测试以上API 只读设置 API setReadOnly(bool) isReadOnly() -> bool 应用场景 控制文本框只读 案例 测试以上API 格式 API currentCharFormat() -> QTextCharFormat setCurrentCharFormat(QTextCharFormat) mergeCurrentCharFormat(QTextCharFormat) 应用场景 字符格式的控制 案例 测试以上API 软换行模式 API lineWrapMode() -> QPlainTextEdit.LineWrapMode setLineWrapMode(QPlainTextEdit.LineWrapMode) 应用场景 设置文本内容超过控件宽度时, 是否进行自动换行 案例 测试以上API 补充 QPlainTextEdit.LineWrapMode QPlainTextEdit.NoWrap 没有软换行 QPlainTextEdit.WidgetWidth 超出控件宽度进行自动换行 覆盖模式 API overwriteMode() -> bool setOverwriteMode(bool) 应用场景 控制是否采用覆盖模式编辑文本 案例 测试以上API Tab控制 API setTabChangesFocus(bool) setTabStopDistance(distance_float) tabChangesFocus() -> bool tabStopDistance() -> float 应用场景 控制Tab的作用, 以及对应的距离 案例 测试以上API 文本操作 API setPlainText(text_str) 设置普通文本内容 insertPlainText(text_str) 插入普通文本 appendPlainText(text_str) 追加普通文本 appendHtml(html_str) 追加HTML字符串 注意 有些标签不支持 表格 列表 图片 ... toPlainText() -> 转换成纯文本 应用场景 追加以及获取文本 案例 测试以上API 块操作 API blockCount() -> int 当前块个数 maximumBlockCount() -> int 最大块个数 setMaximumBlockCount(int) 设置最大块个数 应用场景 设置用户能够输入的最大块数 案例 测试以上API 常用编辑操作 API selectAll() 选中所有 copy() 复制选中文本 cut() 剪切选中文本 paste() 粘贴文本 canPaste() -> bool 判定是否可以粘贴 clear() 清空内容 redo() 重做 isUndoRedoEnabled() -> bool 判定撤销重做是否可用 setUndoRedoEnabled(bool) 设置撤销重做是否可用 undo() 撤销 find(str, QTextDocument.FindFlags) -> bool QTextDocument.FindBackward 向后搜索而不是向前搜索。 QTextDocument.FindCaseSensitively 默认情况下，查找工作区不区分大小写。 指定此选项会将行为更改为区分大小写的查找操作。 QTextDocument.FindWholeWords 使查找匹配仅完整的单词。 zoomIn(int range = 1) 放大缩小 range > 0 放大 range 缩小 zoomOut(int range = 1) 过期 效果和上面的方法相反 应用场景 快速完成编辑操作 案例 测试以上API 滚动 API centerCursor() 控制光标, 尽可能保证光标在文本框中间 ensureCursorVisible() setCenterOnScroll(bool) 传递True 表示, 控制光标(包括尾部), 显示时能够展示在中间位置 注意 必须事先设置好 centerOnScroll() -> bool 滚动控件, 确保光标可见 应用场景 控制文本框的内容滚动 案例 测试以上API 光标 textCursor() -> QTextCursor 获取文本光标对象 cursorForPosition(QPoint) -> QTextCursor 获取指定位置的文本光标对象 cursorWidth() -> int 获取文本光标宽度 setCursorWidth(int) 设置文本光标宽度 cursorRect() -> QRect 获取文本光标矩形 cursorRect(QTextCursor) 获取指定光标对象的矩形 moveCursor(QTextCursor.MoveOperation，QTextCursor.MoveMode) QTextCursor.MoveOperation QTextCursor.NoMove 将光标保持在原位 QTextCursor.Start 移至文档的开头。 QTextCursor.StartOfLine 移动到当前行的开头。 QTextCursor.StartOfBlock 移动到当前块的开头。 QTextCursor.StartOfWord 移动到当前单词的开头。 QTextCursor.PreviousBlock 移动到上一个块的开头。 QTextCursor.PreviousCharacter 移至上一个字符。 QTextCursor.PreviousWord 移到上一个单词的开头。 QTextCursor.Up 向上移动一行。 QTextCursor.Left 向左移动一个字符。 QTextCursor.WordLeft 向左移动一个单词。 QTextCursor.End 移到文档的末尾。 QTextCursor.EndOfLine 移动到当前行的末尾。 QTextCursor.EndOfWord 移到当前单词的末尾。 QTextCursor.EndOfBlock 移动到当前块的末尾。 QTextCursor.NextBlock 移动到下一个块的开头。 QTextCursor.NextCharacter 移动到下一个角色。 QTextCursor.NextWord 转到下一个单词。 QTextCursor.Down 向下移动一行。 QTextCursor.Right 向右移动一个角色。 QTextCursor.WordRight 向右移动一个单词。 QTextCursor.NextCell 移动到当前表中下一个表格单元格的开头。如果当前单元格是行中的最后一个单元格，则光标将移动到下一行中的第一个单元格。 QTextCursor.PreviousCell 移动到当前表内的上一个表格单元格的开头。如果当前单元格是行中的第一个单元格，则光标将移动到上一行中的最后一个单元格。 QTextCursor.NextRow 移动到当前表中下一行的第一个新单元格。 QTextCursor.PreviousRow 移动到当前表中上一行的最后一个单元格。 QTextCursor.MoveMode QTextCursor.MoveAnchor 将锚点移动到与光标本身相同的位置。 QTextCursor.KeepAnchor 将锚固定在原处。 信号 textChanged() 文本改变时 selectionChanged() 选中内容改变时 modificationChanged(bool) 编辑状态改变时 cursorPositionChanged() 光标位置改变时 blockCountChanged(int) 块的个数发生改变时 updateRequest(QRect rect, int dy) 内容更新请求时 copyAvailable(bool) 复制可用时 redoAvailable(bool) 重做可用时 undoAvailable(bool) 撤销可用时 QKeySequenceEdit 描述 控件允许输入QKeySequence, 它通常用作快捷方式。 当控件收到焦点时开始录制，并在用户释放最后一个关键字后一秒钟结束录制 继承 QWidget 功能作用 快捷键 setKeySequence(QKeySequence keySequence) keySequence() -> QKeySequence 清除 clear() 信号 editingFinished() 结束编辑时发射 keySequenceChanged(QKeySequence keySequence) 键位序列改变时发射 补充 QKeySequence 描述 用来描述一个键位序列 键位序列描述了必须一起使用以执行某些操作的键组合 键位序列分类 标准键位序列(QKeySequence.) HelpContents F1 WhatsThis Shift+F1 Open Ctrl+O Close Ctrl+F4, Ctrl+W Save Ctrl+S Quit Ctrl+Q SaveAs Ctrl+Shift+S New Ctrl+N Delete Del Cut Ctrl+X, Shift+Del Copy Ctrl+C, Ctrl+Ins Paste Ctrl+V, Shift+Ins Preferences Ctrl+, Undo Ctrl+Z, Alt+Backspace Redo Ctrl+Y, Shift+Ctrl+Z, Alt+Shift+Backspace Back Alt+Left, Backspace Forward Alt+Right, Shift+Backspace Refresh F5 ZoomIn Ctrl+Plus ZoomOut Ctrl+Minus FullScreen F11, Alt+Enter Print Ctrl+P AddTab Ctrl+T NextChild Ctrl+Tab, Forward, Ctrl+F6 PreviousChild Ctrl+Shift+Tab, Back, Ctrl+Shift+F6 Find Ctrl+F FindNext F3, Ctrl+G FindPrevious Shift+F3, Ctrl+Shift+G Replace Ctrl+H SelectAll Ctrl+A Deselect Ctrl+Shift+A Bold Ctrl+B Italic Ctrl+I Underline Ctrl+U MoveToNextChar Right MoveToPreviousChar Left MoveToNextWord Ctrl+Right MoveToPreviousWord Ctrl+Left MoveToNextLine Down MoveToPreviousLine Up MoveToNextPage PgDown MoveToPreviousPage PgUp MoveToStartOfLine Home MoveToEndOfLine End MoveToStartOfDocument Ctrl+Home MoveToEndOfDocument Ctrl+End SelectNextChar Shift+Right SelectPreviousChar Shift+Left SelectNextWord Ctrl+Shift+Right SelectPreviousWord Ctrl+Shift+Left SelectNextLine Shift+Down SelectPreviousLine Shift+Up SelectNextPage Shift+PgDown SelectPreviousPage Shift+PgUp SelectStartOfLine Shift+Home SelectEndOfLine Shift+End SelectStartOfDocument Ctrl+Shift+Home SelectEndOfDocument Ctrl+Shift+End DeleteStartOfWord Ctrl+Backspace DeleteEndOfWord Ctrl+Del InsertParagraphSeparator Enter InsertLineSeparator Shift+Enter Cancel Escape 自定义键位序列 字符串 \"Ctrl+S\" 枚举值 Qt.Ctrl + Qt.Key_S 注意 优先使用标准键位序列 自定义键位序列, 保证可读, 尽可能不用枚举值对应的整形数据 功能作用 构造函数 QKeySequence(key_str) QKeySequence(QKeySequence.StandardKey key) QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0) 静态方法 fromString(key_str) 转换成可读字符串 toString() -> str 键位个数 count() 步长调节(QAbstractSpinBox) (键盘+鼠标) QSpinBox 描述 主要处理整数和离散值集 1--99 1月--12月 周一--周日 允许用户通过单击向上/向下按钮或按键盘上的上/下来选择一个值来增加/减少当前显示的值。用户还可以手动键入值 旋转框支持整数值 也可以子类化此类实现更多支持 继承 QAbstractSpinBox 功能作用 构造函数 QSpinBox(parent: QWidget = None) 默认功能 调整0到99范围之间的整数 步长调节器 修改文本框内容 设置数值范围 API setMaximum(max_num) 设置最大值 maximum() -> int setMinimum(min_num) 设置最小值 minimum() -> int setRange(min_num, max_num) 设置数值区间 应用场景 控制数据的范围 案例 测试以上API 数值循环 API setWrapping(bool) wrapping() -> bool 应用场景 设置数值达到最大/小时, 跳转到最小/大 案例 测试以上API 设置步长 API setSingleStep(step_int) singleStep() -> int 应用场景 设置步长调节器, 单步步长值 案例 测试以上API 前缀和后缀 API setPrefix(\"周\") 设置前缀作为展示 prefix() -> str setSuffix(\"月\") 设置后缀作为展示 suffix() -> str 应用场景 特定场景下, 设置前缀或者后缀 年月日, 星期 案例 测试以上API 最小值特殊文本 API setSpecialValueText(str) 父类中的方法 当数据到达最小值时, 会显示此字符串 应用场景 设置特殊含义的数值字符串 案例 测试以上API 显示基数(进制) API setDisplayIntegerBase(int) 默认是10 displayIntegerBase() -> int 应用场景 控制文本框内容的显示基数 以几进制的形式进行展示 案例 测试以上API 设置和获取数值 API setValue(int) value() -> int cleanText() -> str 应用场景 设置以及获取数据 案例 测试以上API 自定义展示格式 API 重写 textFromValue(self, p_int) -> format_str 应用场景 展示数值之前, 调用此方法, 转换成对应的格式字符串进行展示 案例 测试以上API 信号 valueChanged(int i) valueChanged(QString text) 重载 QDoubleSpinBox 描述 浮点类型步长调节器 0.00 - 99.99 1.00 % - 99.99 % 既可以通过步长调节器调整数据, 也可以通过文本框直接编辑 继承 QAbstractSpinBox 功能作用 构造函数 QDoubleSpinBox(parent: QWidget = None) 默认功能 步长为1.0, 调整0.00到99.99范围之间的浮点数 步长调节器 修改文本框内容 设置数值范围 API setMaximum(max_num) 设置最大值 maximum() -> float setMinimum(min_num) 设置最小值 minimum() -> float setRange(min_num, max_num) 设置数值区间 应用场景 控制数据的范围 案例 测试以上API 数值循环 API setWrapping(bool) wrapping() -> bool 应用场景 设置数值达到最大/小时, 跳转到最小/大 案例 测试以上API 设置步长 API setSingleStep(step_float) singleStep() -> float 应用场景 设置步长调节器, 单步步长值 案例 测试以上API 前缀和后缀 API setPrefix(\"$\") 设置前缀作为展示 prefix() -> str setSuffix(\"%\") 设置后缀作为展示 suffix() -> str 应用场景 特定场景下, 设置前缀或者后缀 年月日, 星期 案例 测试以上API 最小值特殊文本 API setSpecialValueText(str) 父类中的方法 当数据到达最小值时, 会显示此字符串 应用场景 设置特殊含义的数值字符串 1.0 正常 1.5 2.0 案例 测试以上API 设置小数位数 API setDecimals(int) decimals() -> int 应用场景 设置支持更高精度的数据 案例 测试以上API 设置和获取数值 API setValue(float) 如果设置的小数位数过多, 则会按照真实位数四舍五入 value() -> float 真实的数值 cleanText() -> str 旋转框的文本，不包括任何前缀，后缀或前导或尾随空格 应用场景 设置以及获取数据 案例 测试以上API 自定义展示格式 API 重写 textFromValue(self, p_int) -> format_str 应用场景 展示数值之前, 调用此方法, 转换成对应的格式字符串进行展示 案例 测试以上API 信号 valueChanged(float) valueChanged(QString text) 重载 QDateTimeEdit 描述 编辑日期和时间的单行文本框 既可以用箭头调节, 也可以用键盘编辑输入 可以单独调节某个部分 继承 QAbstractSpinBox 功能作用 构造函数 API QDateTimeEdit(parent: QWidget = None) QDateTimeEdit(Union[QDateTime, datetime.datetime], parent: QWidget = None) QDateTimeEdit(Union[QDate, datetime.date], parent: QWidget = None) QDateTimeEdit(Union[QTime, datetime.time], parent: QWidget = None) 应用场景 根据指定日期或时间, 创建出日期时间编辑器控件 并会初始化该控件展示的section 案例 测试以上API 显示格式 API setDisplayFormat(format_str) 设置日期时间显示格式 displayFormat() -> str 获取日期时间显示格式 应用场景 设置展示的section格式 案例 测试以上API section控制 API sectionCount() -> int 获取section个数 setCurrentSectionIndex(int) 设置当前的section索引 currentSectionIndex() -> int 获取section索引 setCurrentSection(QDateTimeEdit.Section) 设置当前操作的日期时间section currentSection() -> QDateTimeEdit.Section 获取当前的section部分 sectionAt(index_int) -> QDateTimeEdit.Section 获取指定索引位置的section sectionText(QDateTimeEdit.Section) -> str 获取指定section的文本内容 00-01-01 $ 0: 01: 000 应用场景 控制section部分 案例 测试以上API 补充 QDateTimeEdit.Section QDateTimeEdit.NoSection QDateTimeEdit.AmPmSection QDateTimeEdit.MSecSection QDateTimeEdit.SecondSection QDateTimeEdit.MinuteSection QDateTimeEdit.HourSection QDateTimeEdit.DaySection QDateTimeEdit.MonthSection QDateTimeEdit.YearSection 最大和最小日期时间 API 日期时间 最大 setMaximumDateTime(QDateTime) 默认 9999年12月31日 23:59:59 999毫秒 maximumDateTime() -> QDateTime clearMaximumDateTime() 最小 setMinimumDateTime(QDateTime) minimumDateTime() -> QDateTime clearMinimumDateTime() 范围 setDateTimeRange(min_datetime, max_datetime) 日期 最大 setMaximumDate(QDate) 设置最大日期 默认包含9999年12月31日 maximumDate() -> QDate 获取最大日期 clearMaximumDate() 清除自定义最大日期, 恢复默认 最小 setMinimumDate(QDate) 设置最小日期 默认1752年9月14日 minimumDate() -> QDate 获取最小日期 clearMinimumDate() 清除自定义最小日期, 恢复默认 范围 setDateRange(min_date, max_date) 时间 最大 setMaximumTime(QTime) maximumTime() -> QTime clearMaximumTime() 最小 setMinimumTime(QTime) minimumTime() -> QTime clearMinimumTime() 范围 setTimeRange(min_time, max_time) 应用场景 控制日期范围 案例 测试以上API 日历选择控件 API 是否弹出日历选择控件 setCalendarPopup(bool) calendarPopup() 自定义日历选择控件 setCalendarWidget(QCalendarWidget) calendarWidget() -> QCalendarWidget 应用场景 通过日历选择控件, 快速的让用户输入日期 案例 测试以上API 获取日期和时间 API dateTime() -> QDateTime date() -> QDate time() -> QTime 应用场景 获取用户所输入的日期时间 案例 测试以上API 信号 dateTimeChanged(QDateTime datetime) dateChanged(QDate date) timeChanged(QTime time) 补充 QDateTime 描述 日期时间对象 它是QDate和QTime类的组合 包括年月日 时分秒毫秒 功能作用 日期时间对象构造 QDateTime() QDateTime(QDateTime) QDateTime(QDate) QDateTime(QDate, QTime, Qt.TimeSpec = Qt.LocalTime) QDateTime(int, int, int, int, int, second: int = 0, msec: int = 0, timeSpec: int = 0) QDateTime(QDate, QTime, Qt.TimeSpec, int) QDateTime(QDate, QTime, QTimeZone) 静态方法 currentDateTime() 当前时间 currentDateTimeUtc() 世界标准时间 调整日期时间 addYears(int) addMonths(int) addDays(int) addSecs(int) addMSecs(int) setDate(const QDate &date) setTime(const QTime &time) 计算时间差 offsetFromUtc() secsTo(QDateTime) msecsTo(QDateTime) QDate 描述 日期对象 包括年月日 功能作用 日期对象的构造 QDate() QDate(int y, int m, int d) currentDate() 调整日期 setDate(int year, int month, int day) addYears(int nyears) addMonths(int nmonths) addDays(qint64 ndays) 计算时间差 daysTo(const QDate &d) 获取时间 day() 这一个月的第几日 month() 第几月 year() 第几年 dayOfWeek() 这一周 第几日 dayOfYear() 这一年 第几日 daysInMonth() 这一月总共多少天 daysInYear() 这一年总共多少天 QTime 描述 时间对象 包括时分秒毫秒 功能作用 时间对象构造 QTime() QTime(int h, int m, int s = 0, int ms = 0) currentTime() 调整时间 addSecs(int s) addMSecs(int ms) 计算时间差 secsTo(QTime t) 计时 start() restart() elapsed() 以上两个方法启动后, 至此方法调用时, 经历的毫秒数 获取时间 hour() minute() second() msec() 时间日期格式符 日期 d 没有前导零的数字的日期（1到31） dd 有前导零的数字的日期（01到31） ddd 缩写的本地化日期名称（例如'Mon'到'Sun' dddd 完整本地化的日期名称（例如“星期一”到“星期日”） M 没有前导零的数字的月份（1-12） MM 月份为前导零的数字（01-12） MMM 缩写的本地化月份名称（例如'Jan'到'Dec'） MMMM 完整的本地化月份名称（例如“1月”到“12月”） yy 年份为两位数字（00-99） yyyy 年份为四位数字 时间 h 没有前导零的小时（如果显示AM / PM，则为0到23或1到12） hh 前导零的小时（如果AM / PM显示，则为00到23或01到12） H 没有前导零的小时（0到23，即使有AM / PM显示） HH 前导零的小时（00到23，即使有AM / PM显示） m 没有前导零的分钟（0到59） mm 前导零（00到59）的分钟 s 整个秒没有前导零（0到59） ss 带有前导零（00到59） z 第二个小数部分, 没有尾随零的毫秒（0到999） zzz 第二个小数部分, 有尾随零的毫秒（000到999） AP / A 使用AM / PM显示 ap / a 使用am / pm显示 t 时区 相关子类 QDateEdit 描述 基于QDateTimeEdit控件的小控件 主要操作日期部分 继承 QDateTimeEdit 功能作用 构造函数 QDateEdit(QWidget *parent = nullptr) QDateEdit(const QDate &date, QWidget *parent = nullptr) 显示格式 API setDisplayFormat(format_str) 设置日期时间显示格式 displayFormat() -> str 获取日期时间显示格式 应用场景 设置展示的section格式 案例 测试以上API 最大和最小日期 最大 setMaximumDate(QDate) 设置最大日期 默认包含9999年12月31日 maximumDate() -> QDate 获取最大日期 clearMaximumDate() 清除自定义最大日期, 恢复默认 最小 setMinimumDate(QDate) 设置最小日期 默认1752年9月14日 minimumDate() -> QDate 获取最小日期 clearMinimumDate() 清除自定义最小日期, 恢复默认 范围 setDateRange(min_date, max_date) 获取日期 date() -> QDate ... 信号 继承父类 QTimeEdit 描述 基于QDateTimeEdit控件的小控件 主要操作时间部分 继承 QDateTimeEdit 功能作用 构造函数 QTimeEdit(QWidget *parent = nullptr) QTimeEdit(const QTime &time, QWidget *parent = nullptr) 显示格式 API setDisplayFormat(format_str) 设置日期时间显示格式 displayFormat() -> str 获取日期时间显示格式 应用场景 设置展示的section格式 案例 测试以上API 时间 最大 setMaximumTime(QTime) maximumTime() -> QTime clearMaximumTime() 最小 setMinimumTime(QTime) minimumTime() -> QTime clearMinimumTime() 范围 setTimeRange(min_time, max_time) 获取时间 time() -> QTime ... 信号 继承父类 组合框(下拉选择输入) QComboBox 描述 是一个组合控件 默认展示最小的空间给用户操作 可通过下拉选择界面, 选取更多的预置选项 继承 QWidget 功能作用 构造函数 API QComboBox(parent: QWidget = None) 应用场景 构造出一个空白的下拉列表控件 后续通过操作数据的方法设置数据列表 案例 测试以上API 数据操作 API 添加条目项 addItem(str, userData: Any = None) addItem(QIcon, str, userData: Any = None) addItems(Iterable[str]) 插入条目项 insertItem(int, str, userData: Any = None) insertItem(int, QIcon, str, userData: Any = None) insertItems(int, Iterable[str]) 设置条目项 setItemIcon(int, QIcon) setItemText(int, str) setItemData(int, Any, role: int = Qt.UserRole) 删除条目项 removeItem(int index) 插分割线 insertSeparator(int index) 设置当前编辑文本 setCurrentIndex(int index) setCurrentText(QString text) setEditText(QString text) 结合设置可被编辑 了解 模型操作 setModel(QAbstractItemModel model) setModelColumn(int visibleColumn) setRootModelIndex(QModelIndex index) model() modelColumn() rootModelIndex() 视图操作 setView(QAbstractItemView *itemView) view() 代理设置 setItemDelegate(QAbstractItemDelegate *delegate) 应用场景 增删改条目内容 案例 测试以上API 常用数据获取 API count() -> int itemIcon(int index) -> QIcon itemText(int index) -> str itemData(int index) -> Any currentIndex() -> int currentText() -> str 应用场景 获取相关数据 案例 测试以上API 数据限制 API setMaxCount(int max) maxCount() setMaxVisibleItems(int maxItems) maxVisibleItems() 应用场景 限制数据内容显示等限制 案例 测试以上API 尝龟操作 API 可编辑 setEditable(bool editable) isEditable() 可重复 setDuplicatesEnabled(bool enable) duplicatesEnabled() 有框架 setFrame(bool) hasFrame() 图标尺寸 setIconSize(QSize) iconSize() 尺寸调整策略 setSizeAdjustPolicy(QComboBox.SizeAdjustPolicy policy) QComboBox.AdjustToContents 组合框将始终根据内容进行调整 QComboBox.AdjustToContentsOnFirstShow 组合框将在第一次显示时调整其内容。 QComboBox.AdjustToMinimumContentsLength 请改用AdjustToContents或AdjustToContentsOnFirstShow。 QComboBox.AdjustToMinimumContentsLengthWithIcon 组合框将调整为minimumContentsLength加上图标的空间。出于性能原因，请在大型模型上使用此策略。 sizeAdjustPolicy() -> QComboBox.SizeAdjustPolicy setMinimumContentsLength(int characters) minimumContentsLength() -> int 清空 clear() 移除所有项目 clearEditText() 清除组合框中用于编辑的行编辑内容 弹出 showPopup() 完成器 setCompleter(QCompleter completer) completer() -> QCompleter 验证器 setValidator(QValidator validator) validator() 应用场景 看着用吧 案例 测试一下, 以后按需求来用即可! 信号 activated(int index) 某个条目被选中时 必须是用户交互, 造成的值改变才会发射这个信号 activated(QString text) 某个条目被选中时 必须是用户交互, 造成的值改变才会发射这个信号 currentIndexChanged(int index) 当前选中的索引发生改变时 用户交互 代码控制 currentIndexChanged(QString text) 当前选中的索引发生改变时 用户交互 代码控制 currentTextChanged(QString text) 当前的文本内容发生改变时 editTextChanged(QString text) 编辑的文本发生改变时 highlighted(int index) 高亮 highlighted(QString text) 高亮 案例 给定城市数据 city_dic = { \"北京\": { \"东城\": \"001\", \"西城\": \"002\", \"朝阳\": \"003\", \"丰台\": \"004\" }, \"上海\": { \"黄埔\": \"005\", \"徐汇\": \"006\", \"长宁\": \"007\", \"静安\": \"008\", \"松江\": \"009\" }, \"广东\": { \"广州\": \"010\", \"深圳\": \"011\", \"湛江\": \"012\", \"佛山\": \"013\" } } 实现两级联动效果 相关子类 QFontComboBox 描述 组合框中填充了按字母顺序排列的字体系列名称列表 让用户选择字体家族 继承 QComboBox 功能作用 设置和获取当前字体 setCurrentFont(QFont f) currentFont() -> QFont 设置和获取过滤器 setFontFilters(QFontComboBox.FontFilters) fontFilters() -> QFontComboBox.FontFilters 信号 继承 currentIndexChanged(QString text) currentFontChanged(QFont font) 补充 QFontComboBox.FontFilters QFontComboBox.AllFonts 显示所有字体 QFontComboBox.ScalableFonts 显示可缩放字体 QFontComboBox.NonScalableFonts 显示不可缩放的字体 QFontComboBox.MonospacedFonts 显示等宽字体 QFontComboBox.ProportionalFonts 显示比例字体 滑块(QAbstractSlider)(鼠标) QSlider 描述 垂直或水平滑块 它允许用户沿水平或垂直凹槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值 继承 QAbstractSlider 功能作用 继承自父类 刻度控制 API setTickPosition(self, QSlider.TickPosition) QSlider.NoTicks 0 不要画任何刻度线。 QSlider.TicksBothSides 3 在凹槽两侧画刻度线。 QSlider.TicksAbove 1 在（水平）滑块上方绘制刻度线 QSlider.TicksBelow 2 在（水平）滑块下方绘制刻度线 QSlider.TicksLeft 1 在（垂直）滑块的左侧绘制刻度线 QSlider.TicksRight 2 在（垂直）滑块右侧绘制刻度线 sd.tickPosition() -> QSlider.TickPosition sd.setTickInterval(int) 这是值间隔，而不是像素间隔。如果为0，滑块将在singleStep和pageStep之间进行选择 sd.tickInterval() -> int 应用场景 控制滑块刻度位置以及刻度密度 信号 继承自父类 拓展案例 要求 在滑块移动时, 通过标签, 展示滑块当前数值 并要求标签位置, 一直在滑块所在位置中间 示例效果 slider-案例.gif QScrollBar 描述 使用户能够访问比用于显示它的窗口小部件更大的文档部分 一般是结合QAbstractScrollArea使用 滚动条通常包括四个单独的控件：滑块，滚动箭头和页面控件 继承 QAbstractSlider 功能作用 继承自父类 注意, 控件尺寸需要手动调整 如果想要调整滚动条长度, 参考右图 信号 继承自父类 QDial 描述 倒圆的范围控制 比如汽车仪表盘上的速度计 继承 QAbstractSlider 功能作用 继承自父类 是否显示刻度 setNotchesVisible(bool) notchesVisible() -> bool 大刻度控制 setPageStep(int) 是否启用包裹 setWrapping(bool) 启用则会在控件周边都设置上刻度, 可以任意指向 wrapping() -> bool 凹口之间的目标像素数 setNotchTarget(float) notchTarget() -> float 缺口大小 notchSize() 默认值1 信号 继承自父类 橡皮筋选中 QRubberBand 描述 提供一个矩形或线来指示选择或边界 一般结合鼠标事件一同协作 继承 QWidget 功能作用 构造函数 QRubberBand(QRubberBand.Shape, QWidget) QRubberBand.Line QRubberBand.Rectangle 移动 move(x, y) move(QPoint) 调整大小 resize(width, height) resize(QSize) 统一设置 setGeometry(int x, int y, int width, int height) setGeometry(QRect rect) 形状获取 shape() -> QRubberBand.Shape 信号 继承父类 案例 在一个空白窗口内, 展示多个复选框控件 通过橡皮筋实现批量选中与取消选中效果 效果图 对话框(QDialog) QFontDialog 描述 提供了一种选择字体的对话框控件 继承 QDialog 功能作用 构造函数 QFontDialog(parent: QWidget = None) QFontDialog(QFont, parent: QWidget = None) 打开对话框 open(self) open(PYQT_SLOT) 打开后, 会自动连接fontSelected信号与此处指定的槽函数 exec() -> int 当前字体 setCurrentFont(QFont) currentFont() -> QFont 最终选中字体 selectedFont() -> QFont 选项控制 setOption(QFontDialog.FontDialogOption, on=True) on = True 设置该选项 on = False 取消该选项 setOptions(QFontDialog.FontDialogOption) 设置多个选项 testOption(QFontDialog.FontDialogOption) 测试某个选项是否生效 options() -> QFontDialog.FontDialogOption 获取当前的选项 补充 QFontDialog.FontDialogOption QFontDialog.NoButtons 不显示“ 确定”和“ 取消”按钮。（对“实时对话框”有用。） QFontDialog.DontUseNativeDialog 在Mac上使用Qt的标准字体对话框而不是Apple的原生字体面板。 QFontDialog.ScalableFonts 显示可缩放字体 QFontDialog.NonScalableFonts 显示不可缩放的字体 QFontDialog.MonospacedFonts 显示等宽字体 QFontDialog.ProportionalFonts 显示比例字体 静态方法 getFont(parent: QWidget = None) -> Tuple[QFont, bool] getFont(QFont, parent: QWidget = None, caption: str = '', options: QFontDialog.FontDialogOption) -> Tuple[QFont, bool] 参数 1: 默认字体 父控件 对话框标题 选项 返回值 (最终字体, 是否点击确认) 信号 currentFontChanged(QFont) 当前字体发生改变时 fontSelected(QFont) 最终选择字体时 QColorDialog 描述 颜色对话框的功能是允许用户选择颜色 继承 QDialog 功能作用 构造函数 QColorDialog(parent: QWidget = None) QColorDialog(Union[QColor, Qt.GlobalColor, QGradient], parent: QWidget = None) 打开对话框 open(self) open(PYQT_SLOT) 打开后, 会自动连接colorSelected信号与此处指定的槽函数 exec() -> int 当前颜色 setCurrentColor(QColor()) currentColor() -> QColor 最终选中颜色 selectedColor() 选项控制 setOption(self, QColorDialog.ColorDialogOption, on: bool = True) setOptions(self, Union[QColorDialog.ColorDialogOptions, QColorDialog.ColorDialogOption]) testOption(self, QColorDialog_ColorDialogOption) 补充 QColorDialog.ColorDialogOption QColorDialog.ShowAlphaChannel 允许用户选择颜色的alpha分量。 QColorDialog.NoButtons 不显示“ 确定”和“ 取消”按钮。（对“实时对话框”有用。） QColorDialog.DontUseNativeDialog 使用Qt的标准颜色对话框而不是操作系统原生颜色对话框。 静态方法 customCount() -> int setCustomColor(int index, QColor color) customColor(int index) -> QColor setStandardColor(int index, QColor color) standardColor(int index) -> QColor getColor(initial: Union[QColor, Qt.GlobalColor, QGradient] = Qt.white, parent: QWidget = None, title: str = '', options: Union[QColorDialog.ColorDialogOptions, QColorDialog.ColorDialogOption] = QColorDialog.ColorDialogOptions()) -> QColor 信号 colorSelected(QColor color) currentColorChanged(QColor color) QFileDialog 描述 提供了一个对话框，允许用户选择文件或目录 允许用户遍历文件系统，以选择一个或多个文件或目录 继承 QDialog 功能作用 最简单的获取方式(静态方法) 获取文件 getOpenFileName(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0) -> Tuple[str, str] getOpenFileNames(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0) -> Tuple[List[str], str] getOpenFileUrl(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0, supportedSchemes: Iterable[str] = []) -> Tuple[QUrl, str] getOpenFileUrls(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0, supportedSchemes: Iterable[str] = []) -> Tuple[List[QUrl], str] getSaveFileName(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0) -> Tuple[str, str] getSaveFileUrl(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '', initialFilter: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = 0, supportedSchemes: Iterable[str] = []) -> Tuple[QUrl, str] 获取文件夹 getExistingDirectory(parent: QWidget = None, caption: str = '', directory: str = '', options: Union[QFileDialog.Options, QFileDialog.Option] = QFileDialog.ShowDirsOnly) -> str getExistingDirectoryUrl(parent: QWidget = None, caption: str = '', directory: QUrl = QUrl(), options: Union[QFileDialog.Options, QFileDialog.Option] = QFileDialog.ShowDirsOnly, supportedSchemes: Iterable[str] = []) -> QUrl 补充 过滤字符串格式 名称1(.jpg .png);;名称2(*.py) 构造函数 QFileDialog(QWidget, Union[Qt.WindowFlags, Qt.WindowType]) QFileDialog(parent: QWidget = None, caption: str = '', directory: str = '', filter: str = '') 接收模式 acceptMode() -> QFileDialog.AcceptMode setAcceptMode(QFileDialog.AcceptMode) 补充 QFileDialog.AcceptMode QFileDialog.AcceptOpen 打开 QFileDialog.AcceptSave 保存 默认后缀 setDefaultSuffix(str) defaultSuffix() -> str 设置文件模式 setFileMode(QFileDialog.FileMode) fileMode() -> QFileDialog.FileMode 补充 QFileDialog.FileMode QFileDialog.AnyFile 文件的名称，无论是否存在。 QFileDialog.ExistingFile 单个现有文件的名称。 QFileDialog.Directory 目录的名称。显示文件和目录。但是，本机Windows文件对话框不支持在目录选择器中显示文件。 QFileDialog.ExistingFiles 零个或多个现有文件的名称。 设置名称过滤器 setNameFilter(str) setNameFilters(str) 显示信息的详细程度 setViewMode(QFileDialog.ViewMode) viewMode() -> QFileDialog.ViewMode 补充 QFileDialog.ViewMode QFileDialog.Detail QFileDialog.List 经测试, win10下不太灵光 设置指定角色的标签名称 setLabelText(self, QFileDialog.DialogLabel, str) QFileDialog.FileName QFileDialog.Accept QFileDialog.Reject QFileDialog.FileType QFileDialog.LookIn 打开对话框 open(self) open(PYQT_SLOT) 打开后, 会自动连接 filesSelected 信号与此处指定的槽函数 exec() -> int 信号 currentChanged(path_str) 当前路径发生改变时 currentUrlChanged(QUrl) 当前路径url发生改变时 directoryEntered(directory_str) 打开选中文件夹时 directoryUrlEntered(QUrl directory) 打开选中文件夹url时 filterSelected(filter_str) 选择名称过滤器时 fileSelected(str) 最终选择文件时 filesSelected([str]) 选择多个文件时 urlSelected(QUrl url) 最终选择url时 urlsSelected(List[QUrl]) 最终选择多个url时 作业 QInputDialog 描述 提供了一个简单方便的对话框，获得来自用户的单个值 输入值可以是字符串，数字或列表中的项目 设置标签以告知用户应输入的内容 继承 QDialog 功能作用 常用的静态方法 getInt(QWidget, str, str, value: int = 0, min: int = -2147483647, max: int = 2147483647, step: int = 1, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()) -> Tuple[int, bool] getDouble(QWidget, str, str, value: float = 0, min: float = -2147483647, max: float = 2147483647, decimals: int = 1, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()) -> Tuple[float, bool] getDouble(QWidget, str, str, float, float, float, int, Union[Qt.WindowFlags, Qt.WindowType], float) -> Tuple[float, bool] getText(QWidget, str, str, echo: QLineEdit.EchoMode = QLineEdit.Normal, text: str = '', flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags(), inputMethodHints: Union[Qt.InputMethodHints, Qt.InputMethodHint] = Qt.ImhNone) -> Tuple[str, bool] getMultiLineText(QWidget, str, str, text: str = '', flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags(), inputMethodHints: Union[Qt.InputMethodHints, Qt.InputMethodHint] = Qt.ImhNone) -> Tuple[str, bool] getItem(QWidget, str, str, Iterable[str], current: int = 0, editable: bool = True, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags(), inputMethodHints: Union[Qt.InputMethodHints, Qt.InputMethodHint] = Qt.ImhNone) -> Tuple[str, bool] 构造函数 QInputDialog(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()) 选项设置 setOption(self, QInputDialog.InputDialogOption, on: bool = True) setOptions(self, Union[QInputDialog.InputDialogOptions, QInputDialog.InputDialogOption]) testOption(self, QInputDialog.InputDialogOption) -> bool options(self) -> QInputDialog.InputDialogOptions 补充 QInputDialog.InputDialogOption QInputDialog.NoButtons 不显示“ 确定”和“ 取消”按钮（对“实时对话框”有用）。 QInputDialog.UseListViewForComboBoxItems 使用QListView而不是不可编辑的QComboBox来显示使用setComboBoxItems（）设置的项目。 QInputDialog.UsePlainTextEditForTextInput 使用QPlainTextEdit进行多行文本输入。该值在5.2中引入。 输入模式 inputMode(self) -> QInputDialog.InputMode setInputMode(self, QInputDialog.InputMode) QInputDialog.InputMode TextInput IntInput DoubleInput 界面文本设置 setLabelText(str) labelText(self) -> str setOkButtonText(str) setCancelButtonText(str) 各个小分类设置 整型 setIntMaximum(self, int) intMaximum(self) -> int setIntMinimum(self, int) intMinimum(self) -> int setIntRange(self, int, int) setIntStep(self, int) intStep(self) -> int setIntValue(self, int) intValue(self) -> int 浮点型 setDoubleMaximum(self, float) doubleMaximum() -> float setDoubleDecimals(self, int) doubleDecimals() -> int setDoubleMinimum(self, float) doubleMinimum(self) -> float setDoubleRange(self, float, float) setDoubleStep(self, float) doubleStep(self) -> float setDoubleValue(self, float) doubleValue(self) -> float 字符串 setTextEchoMode(self, QLineEdit.EchoMode) textEchoMode(self) -> QLineEdit.EchoMode setTextValue(self, str) textValue(self) -> str 下拉列表 setComboBoxItems(self, Iterable[str]) comboBoxItems(self) -> List[str] setComboBoxEditable(self, bool) isComboBoxEditable(self) -> bool 信号 intValueChanged(int value) intValueSelected(int value) doubleValueChanged(double value) doubleValueSelected(double value) textValueChanged(text_str) textValueSelected(text_str) 日期 QCalendarWidget 描述 提供了一个基于每月日历控件，允许用户选择一个日期 图示 继承 QWidget 功能作用 构造函数 QCalendarWidget(parent: QWidget = None) 日期范围 setMinimumDate(QDate date) minimumDate() -> QDate setMaximumDate(QDate date) maximumDate() -> QDate setDateRange(QDate min, QDate max) 日期编辑 setDateEditEnabled(bool enable) isDateEditEnabled() -> bool 默认可以被编辑 setDateEditAcceptDelay(int delay) dateEditAcceptDelay() -> int 当控件获取焦点时, 直接输入数字, 可以快速修改日期 日期获取 monthShown() -> int yearShown() -> int selectedDate() -> QDate 格式外观 导航条 isNavigationBarVisible() -> bool setNavigationBarVisible(bool) 一周的第一天 setFirstDayOfWeek(Qt.DayOfWeek dayOfWeek) firstDayOfWeek() -> Qt.DayOfWeek 网格显示 isGridVisible() -> bool setGridVisible(bool) 文本格式 setHeaderTextFormat(QTextCharFormat format) headerTextFormat() -> QTextCharFormat setHorizontalHeaderFormat(QCalendarWidget.HorizontalHeaderFormat format) horizontalHeaderFormat() -> QCalendarWidget.HorizontalHeaderFormat 补充 QCalendarWidget.HorizontalHeaderFormat QCalendarWidget.SingleLetterDayNames 英文 M 中文 周 QCalendarWidget.ShortDayNames 英文 Mon 中文 周一 QCalendarWidget.LongDayNames 英文 Monday 中文 星期一 QCalendarWidget.NoHorizontalHeader 标题是隐藏的。 setVerticalHeaderFormat(QCalendarWidget.VerticalHeaderFormat format) verticalHeaderFormat() -> QCalendarWidget.VerticalHeaderFormat 补充 QCalendarWidget.VerticalHeaderFormat QCalendarWidget.ISOWeekNumbers 标题显示ISO周数，如QDate.weekNumber()所述。 QCalendarWidget.NoVerticalHeader 标题是隐藏的。 setWeekdayTextFormat(self, Qt.DayOfWeek, QTextCharFormat) weekdayTextFormat(Qt.DayOfWeek dayOfWeek) -> QTextCharFormat setDateTextFormat(QDate date, QTextCharFormat format) dateTextFormat(self, Union[QDate, datetime.date]) -> QTextCharFormat dateTextFormat(self) -> object 选中 setSelectedDate(QDate date) setSelectionMode(QCalendarWidget.SelectionMode mode) selectionMode() -> QCalendarWidget.SelectionMode 补充 QCalendarWidget.SelectionMode QCalendarWidget.NoSelection 日期无法选择。 QCalendarWidget.SingleSelection 可以选择单日期。 常用的方法 showToday() showSelectedDate() showNextYear() showPreviousYear() showNextMonth() showPreviousMonth() setCurrentPage(int year, int month) 信号 activated(QDate date) 只要用户按下Return或Enter键或双击日历小部件中的日期，就会发出此信号。 clicked(QDate date) 单击有效日期时才会发出信号 currentPageChanged(int year, int month) 当前显示的月份更改时会发出此信号。新的一年和一个月作为参数传递。 selectionChanged() 当前选择的日期更改时会发出此信号 鼠标 代码 展示控件 QLabel 描述 提供了文本或图像的显示 普通文本 数字 富文本 QLabel-超链接 图片 QLabel-动画 没有提供用户交互功能 继承 QFrame 功能作用 构造函数 QLabel(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()) QLabel(str, parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags()) 对齐 alignment() -> Qt.Alignment setAlignment(Qt.Alignment) 缩进和边距 setIndent(int) indent() -> int setMargin(int) margin() -> int 文本格式 setTextFormat(Qt.TextFormat) textFormat() Qt.TextFormat Qt.PlainText 文本字符串被解释为纯文本字符串。 Qt.RichText 文本字符串被解释为富文本字符串。有关富文本的定义，请参阅支持的HTML子集。 Qt.AutoText 自动识别是否是富文本 小伙伴 buddy() -> QWidget setBuddy(QWidget buddy) 快捷键会作用在小伙伴身上 内容缩放 hasScaledContents() -> bool setScaledContents(bool) 缩放内容, 适应控件大小 针对于图片有效 文本交互标志 setTextInteractionFlags(Qt.TextInteractionFlags flags) textInteractionFlags() -> Qt.TextInteractionFlags 补充 Qt.TextInteractionFlag Qt.NoTextInteraction 不可能与文本进行交互。 Qt.TextSelectableByMouse 可以使用鼠标选择文本并使用上下文菜单或标准键盘快捷键将其复制到剪贴板。 Qt.TextSelectableByKeyboard 可以使用键盘上的光标键选择文本。显示文本光标。 Qt.LinksAccessibleByMouse 可以使用鼠标突出显示和激活链接。 Qt.LinksAccessibleByKeyboard 可以使用选项卡聚焦链接并使用enter激活。 Qt.TextEditable 该文字完全可编辑。 Qt.TextEditorInteraction 文本编辑器的默认值。 TextSelectableByMouse | TextSelectableByKeyboard | TextEditable Qt.TextBrowserInteraction QTextBrowser的默认值。 TextSelectableByMouse | LinksAccessibleByMouse | LinksAccessibleByKeyboard 选中文本 setSelection(int start, int length) hasSelectedText() -> bool selectedText() -> str selectionStart() -> int 外部链接 openExternalLinks() -> bool setOpenExternalLinks(bool open) 单词换行 setWordWrap(bool on) wordWrap() -> bool 内容操作 文本字符串 text() -> str setText(QString) 数值数据 setNum(int num) setNum(double num) 图形图像 setPicture(QPicture) picture() -> QPicture setPixmap(QPixmap) pixmap() -> QPixmap 动图 setMovie(QMovie movie) movie() -> QMovie 此类用于显示没有声音的简单动画 常用操作 setScaledSize(QSize) setPaused(bool) -> void setSpeed(int percentSpeed) setSpeed(200) 两倍速 start() stop() 清空 clear() 信号 linkActivated(link_str) linkHovered(link_str) QLCDNumber 描述 展示LCD样式的数字 它可以显示几乎任何大小的数字 它可以显示十进制，十六进制，八进制或二进制数 能够展示的字符 0/O, 1, 2, 3, 4, 5/S, 6, 7, 8, 9/g A, B, C, D, E, F, h, H, L, o, P, r, u, U, Y : ' 空格 继承 QFrame 功能作用 构造函数 QLCDNumber(parent: QWidget = None) QLCDNumber(int, parent: QWidget = None) 参数1代表展示的数值位数 设置显示数值 display(str) display(float) display(int) intValue() -> int value() -> float 位数限制 setDigitCount(int) digitCount() -> int 模式设置 setMode(self, QLCDNumber.Mode) mode(self) -> QLCDNumber.Mode QLCDNumber.Hex 十六进制 QLCDNumber.Dec 十进制 QLCDNumber.Oct 八进制 QLCDNumber.Bin 二进制 快捷 setHexMode（） setDecMode（） setOctMode（） setBinMode（） 溢出 checkOverflow(self, float) -> bool checkOverflow(self, int) -> bool 分段样式 setSegmentStyle(self, QLCDNumber.SegmentStyle) segmentStyle(self) -> QLCDNumber.SegmentStyle Outline 生成填充了背景颜色的凸起部分 Filled 默认值 生成填充前景色的凸起部分。 Flat 生成填充前景色的平坦段。 信号 overflow() 数据溢出时发射 QProgressBar 描述 提供一个水平或垂直进度条 进度条用于向用户提供操作进度的指示，并向他们保证应用程序仍在运行 继承 QWidget 功能作用 构造函数 QProgressBar(self) 格式设置 设置范围和当前值 setMinimum(self, int) minimum() -> int setMaximum(self, int) maximum() -> int setRange(self, int, int) setValue(self, int) reset() value() 注意 最大值和最小值如果都是0, 则进入繁忙提示 setFormat(self, str) ％p 百分比 ％v 当前值 ％m 总值 format() -> str resetFormat() 格式字符对齐方式 setAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag]) 文本操作 setTextVisible(bool) text() setTextDirection(QProgressBar.Direction) BottomToTop = 1 TopToBottom = 0 仅仅对于垂直进度条有效 方向 setOrientation(Qt.Orientation) Qt.Horizo​​ntal Qt.Vertical orientation() -> Qt.Orientation 倒立外观 setInvertedAppearance(bool) 信号 valueChanged(int) 对话框(QDialog) QMessageBox 描述 用于通知用户或请求用户的提问和接收应答一个模态对话框 对话框的构成 图标可以使用标准图标 效果图 继承 QDialog 功能作用 构造函数 QMessageBox(parent: QWidget = None) QMessageBox(QMessageBox.Icon, str, str, buttons: Union[QMessageBox.StandardButtons, QMessageBox.StandardButton] = QMessageBox.NoButton, parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.Dialog|Qt.MSWindowsFixedSizeDialogHint) 展示 exec() open() 内容展示 对话框标题 setWindowTitle(str) 图标 标准图标 setIcon(QMessageBox.Icon) 自定义图标 setIconPixmap(QPixmap) 主要标题 setText(str) 提示文本 setInformativeText(str) 详细文本 setDetailedText(self, str) 按钮 添加按钮 addButton(self, QAbstractButton, QMessageBox.ButtonRole) addButton(self, str, QMessageBox.ButtonRole) -> QPushButton addButton(self, QMessageBox.StandardButton) -> QPushButton 获取按钮 button(self, QMessageBox.StandardButton) -> QAbstractButton buttonRole(self, QAbstractButton) -> QMessageBox.ButtonRole buttons(self) -> List[QAbstractButton] 默认按钮 setDefaultButton(self, QPushButton) setDefaultButton(self, QMessageBox.StandardButton) defaultButton(self) -> QPushButton setEscapeButton(self, QAbstractButton) setEscapeButton(self, QMessageBox.StandardButton) 被点击的按钮 clickedButton(self) -> QAbstractButton 补充 QMessageBox.ButtonRole InvalidRole 该按钮无效。 AcceptRole 单击该按钮将使对话框被接受（例如，确定）。 RejectRole 单击该按钮会导致拒绝对话框（例如取消）。 DestructiveRole 单击该按钮会导致破坏性更改（例如，对于Discarding Changes）并关闭对话框。 ActionRole 单击该按钮将导致更改对话框中的元素。 HelpRole 可以单击该按钮以请求帮助。 YesRole 按钮是一个“是”的按钮。 NoRole 按钮是一个“无”按钮。 ApplyRole 该按钮应用当前更改。 ResetRole 该按钮将对话框的字段重置为默认值。 QMessageBox.StandardButton QMessageBox.Ok 使用AcceptRole定义的“确定”按钮。 QMessageBox.Open 使用AcceptRole定义的“打开”按钮。 QMessageBox.Save 使用AcceptRole定义的“保存”按钮。 QMessageBox.Cancel 使用RejectRole定义的“取消”按钮。 QMessageBox.Close 使用RejectRole定义的“关闭”按钮。 QMessageBox.Discard “丢弃”或“不保存”按钮，具体取决于使用DestructiveRole定义的平台。 QMessageBox.Apply 使用ApplyRole定义的“应用”按钮。 QMessageBox.Reset 使用ResetRole定义的“重置”按钮。 QMessageBox.RestoreDefaults 使用ResetRole定义的“恢复默认值”按钮。 QMessageBox.Help 使用HelpRole定义的“帮助”按钮。 QMessageBox.SaveAll 使用AcceptRole定义的“全部保存”按钮。 QMessageBox.Yes 使用YesRole定义的“是”按钮。 QMessageBox.YesToAll 使用YesRole定义的“Yes to All”按钮。 QMessageBox.No 使用NoRole定义的“否”按钮。 QMessageBox.NoToAll 使用NoRole定义的“No to All”按钮。 QMessageBox.Abort 使用RejectRole定义的“Abort”按钮。 QMessageBox.Retry 使用AcceptRole定义的“重试”按钮。 QMessageBox.Ignore 使用AcceptRole定义的“忽略”按钮。 QMessageBox.NoButton 无效按钮。 信号 QErrorMessage QProgressDialog 必备专题 内存管理机制 QObject继承树 所有的对象都是直接或者间接的继承自QObject QObjects在一个对象树中组织他们自己 当创建一个QObject时，如果使用了其他对象作为其父对象 那么，它就会被添加到父对象的children()列表中 当父对象被销毁时，这个QObject也会被销毁 QWidget 扩展了父-子关系 当一个控件设置了父控件 会包含在父控件内部 受父控件区域裁剪 父控件被删除时, 子控件会自动删除 场景案例 一个对话框, 上面有很多操作按钮(取消, OK) 按钮和对话框本身是父子控件关系 我们操作的时候, 是操作的对话框控件本身, 而不是其内部的子控件(按钮) 当对话框被删除时, 内部的子控件也会自动的删除 非常合理 信号与槽机制 基本概念 信号(Signal)和槽(Slot)是Qt中的核心机制, 主要作用在于对象之间进行通讯 信号 当一个控件的状态发生改变时, 向外界发出的信息 槽 一个执行某些操作的函数/方法 所有继承自QWidget的控件都支持\"信号与槽\"的机制 机制描述 手动操作 信号 槽 自动操作 当信号发出时, 连接的槽函数会自动执行 基本使用介绍 信号 控件内置的一些 QPushButton().pressed QPushButton().clicked ... 也可以自定义 pyqtSignal() 槽 不同控件内置额槽函数 自定义的函数/方法 连接方式 object.信号.connect(槽函数) 特性 一个信号可以连接多个槽函数 一个信号也可以连接另外一个信号 信号的参数可以是任何Python类型 一个槽可以监听多个信号 ... 高级 自定义信号 带参数 信号的操作 连接 断开 发射 自定义槽函数 lamda表达式 装饰器信号与槽 事件机制 相比较于\"信号与槽\"机制 信号与槽机制是对事件机制的高级封装 事件机制更偏底层(远离用户) 图解 应用 一般情况下, 我们直接通过内置的\"信号与槽\"就可以解决一般通讯问题 QPushButton的 clicked 等信号 但, 有些控件并没有提供给我们想要的信号, 我们就需要自己重写具体的事件函数, 来捕获产生的事件, 做相应的处理 QLabel 并没有clicked信号 某些场景并不会把我们想要捕获的事件传递给特定函数, 而是做了其他的额外处理, 此时, 我们可以重写事件的分发函数event() 例如: 想捕获用户Tab键的点击 当用户点击了Tab键, 默认是切换焦点 并不会把这个事件分发给keyPressEvent函数 此时, 就需要我们自己重写event, 来做分发处理 如果想同时对多个不同的控件进行捕获Tab点击, 那么每个都重写event()函数, 也是非常麻烦的, 所以, 考虑 安装\"事件过滤器\" QApplication对象的事件过滤器, 可以拦截所有的QObject事件; 一般不怎么使用 QApplication对象的notify()更不怎么用, 会大大降低程序性能 事件的传递 如果一个控件没有处理该事件, 则会自动传递给父控件进行处理 事件对象具备两个特殊方法 accept() 自己处理了这个事件, 并告诉系统不要再向上层传递 ignore() 自己忽略了这个事件, 告诉系统, 继续往后传递去 位置大小 控件坐标系 左上角为坐标原点，向右为x轴正方向，向下为y轴正方向 图示 控件位置参照 父控件 顶层控件则参照桌面 ... 09-布局管理 布局概念 布局就是指 按照某种规则将子控件摆放在父控件中 布局的方式 手动布局 绝对布局 直接给定具体的坐标信息和尺寸信息 设置之后, 后续如果不重新设置, 则一直不变 操作方法 move(x, y) resize(width, height) 重写resizeEvent(evt) 在内部, 根据父控件的尺寸大小的调整, 重新计算 布局管理器 包含了一些特定的规则 横着水平排 竖着垂直排 网格排 表单排 ... 使用这些布局管理器进行布局, 可以快速的实现指定布局效果, 不需要手动计算位置尺寸 布局管理器概念 Qt包含一个布局管理类的集合，它们被用来描述控件如何在应用程序的用户界面中呈现的 当可用空间发生变化时，这些布局将自动调整控件的位置和大小 布局管理器不是界面控件，而是界面控件的\"定位策略\" 所有QWidget类别及其子类都可以用布局来管理它们的子控件 布置子控件。 最高层窗口可感知的默认大小。 最高层窗口可感知的最小大小。 调整大小的处理。 当内容改变的时候自动更新： 字体大小、文本或者子控件的其它内容。 隐藏或者显示子控件。 移除一些子控件。 布局管理器的继承图 QLayout QBoxLayout QHBoxLayout QVBoxLayout QGridLayout QStackedLayout QFormLayout 布局的简单使用演示 创建布局对象 不需要设置父对象 layout = QLayout() 设置布局对象参数 margin setContentsMargins(self, int, int, int, int) spacing setSpacing(self, int) alignment setAlignment(self, QWidget, Union[Qt.Alignment, Qt.AlignmentFlag]) -> bool setAlignment(self, QLayout, Union[Qt.Alignment, Qt.AlignmentFlag]) -> bool setAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag]) 设置给需要布局子控件的父控件\\调整方向 QWidget.setLayout(QLayout) QWidget.setLayoutDirection(Qt.RightToLeft) Qt.LeftToRight 从左到右的布局。 Qt.RightToLeft 从右到左的布局。 Qt.LayoutDirectionAuto 自动布局。 QWidget.unsetLayoutDirection() 将布局控件内部的子控件添加到布局管理器中, 自动进行布局 注意, 创建子控件时, 不需要设置父控件 布局管理器的详细使用 基类 QLayout 作用 布局管理器的抽象基类 功能作用 小控件之间的间距 setSpacing(int) spacing() -> int 外边距 setContentsMargins(int left，int top，int right，int bottom) 在大多数平台上，边距在所有方向上都是11像素 添加子控件 addWidget(QWidget w) 替换子控件 replaceWidget（QWidget from，QWidget to，Qt :: FindChildOptions options = Qt :: FindChildrenRecursively） 注意 被替换的控件, 不再被此布局管理; 隐藏 删除 重新添加到新的布局中 添加子布局 addLayout(QLayout layout) 能用性 isEnabled() -> bool setEnabled(bool) QBoxLayout 作用 提供水平或垂直方向的布局管理器 这个一般很少直接用, 会选择用两个封装好的子类 功能作用 构造函数 QBoxLayout(QBoxLayout.Direction, parent: QWidget = None) parent一般不写 QBoxLayout.Direction QBoxLayout.LeftToRight 从左到右水平。 QBoxLayout.RightToLeft 从右到左水平。 QBoxLayout.TopToBottom 从上到下垂直。 QBoxLayout.BottomToTop 从下到上垂直。 修改方向 setDirection(QBoxLayout_Direction) direction(self) -> QBoxLayout.Direction 添加元素 添加控件 addWidget(self, QWidget, stretch: int = 0, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) insertWidget(self, int, QWidget, stretch: int = 0, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) 添加子布局 addLayout(self, QLayout, stretch: int = 0) insertLayout(self, int, QLayout, stretch: int = 0) 替换控件 replaceWidget(self, QWidget, QWidget, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QLayoutItem 移除控件 removeWidget(self, QWidget) 或者 QWidget.hide() show()会再次参与布局 添加空白 addSpacing(self, int) insertSpacing(self, int, int) 添加伸缩(弹簧) addStretch(self, stretch: int = 0) insertStretch(self, int, stretch: int = 0) stretch（int index） 设置伸缩因子 setStretchFactor(self, QWidget, int) -> bool setStretchFactor(self, QLayout, int) -> bool 边距 setContentsMargins(self, int, int, int, int) setSpacing(self, int) spacing() -> int QHBoxLayout 继承父类 只是在构造函数中确定了方向为水平方向 也可以改 QVBoxLayout 继承父类 只是在构造函数中确定了方向为垂直方向 也可以改 QFormLayout 应用场景 表单样例 管理输入控件及其关联标签的形式 它以两列的形式列出其子元素。 左列由标签组成，右列由“字段”小部件（行编辑器，旋转框等）组成。 功能作用 构造函数 QFormLayout(parent: QWidget = None) parent一般不写 行操作 添加行 addRow(self, QWidget, QWidget) addRow(self, QWidget, QLayout) addRow(self, str, QWidget) addRow(self, str, QLayout) addRow(self, QWidget) addRow(self, QLayout) 插入行 insertRow(self, int, QWidget, QWidget) insertRow(self, int, QWidget, QLayout) insertRow(self, int, str, QWidget) insertRow(self, int, str, QLayout) insertRow(self, int, QWidget) insertRow(self, int, QLayout) 获取行信息 getWidgetPosition(self, QWidget) -> Tuple[int, QFormLayout.ItemRole] getLayoutPosition(self, QLayout) -> Tuple[int, QFormLayout.ItemRole] 行的总个数 rowCount() -> int 修改行 setLayout(self, int, QFormLayout.ItemRole, QLayout) setWidget(self, int, QFormLayout.ItemRole, QWidget) 注意 根据行号和角色, 设置相关控件或布局，如果有必要会延长布局 如果单元格已被占用，则不会设置成功 移除行(删除子控件) removeRow(self, int) removeRow(self, QWidget) removeRow(self, QLayout) 移除行(不删除子控件) takeRow(self, int) -> QFormLayout.TakeRowResult takeRow(self, QWidget) -> QFormLayout.TakeRowResult takeRow(self, QLayout) -> QFormLayout.TakeRowResult 标签操作 labelForField() labelForField(self, QWidget) -> QWidget labelForField(self, QLayout) -> QWidget 补充 QFormLayout.ItemRole(角色) QFormLayout.LabelRole 标签 QFormLayout.FieldRole 输入框 QFormLayout.SpanningRole 跨越标签和输入框的控件 行的包装策略 setRowWrapPolicy(QFormLayout.RowWrapPolicy) rowWrapPolicy() -> QFormLayout.RowWrapPolicy 补充 QFormLayout.DontWrapRows 字段总是放在标签旁边。 QFormLayout.WrapLongRows 标签被赋予足够的水平空间以适合最宽的标签，其余的空间被赋予字段。 如果字段的最小大小比可用空间宽，则该字段将换行到下一行。 QFormLayout.WrapAllRows 字段总是位于其标签下方。 对齐方式 setFormAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag]) formAlignment() -> Qt.Alignment setLabelAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag]) labelAlignment(self) -> Qt.Alignment 间距 setVerticalSpacing(int) verticalSpacing() -> int setHorizo​​ntalSpacing(int) horizo​​ntalSpacing() -> int spacing() -> int 字段增长策略 setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy) fieldGrowthPolicy() -> QFormLayout.FieldGrowthPolicy 补充 QFormLayout.FieldsStayAtSizeHint 这些领域永远不会超出其有效大小的提示。这是QMacStyle的默认值。 QFormLayout.ExpandingFieldsGrow 水平大小策略为Expanding或MinimumExpanding的字段将增长以填充可用空间。其他领域不会超出其有效大小提示。这是Plastique的默认政策。 QFormLayout.AllNonFixedFieldsGrow 具有允许它们增长的大小策略的所有字段将增长以填充可用空间。这是大多数样式的默认策略。 布局项操作(了解) addItem(self, QLayoutItem) removeItem(self, QLayoutItem) itemAt(self, int, QFormLayout.ItemRole) -> QLayoutItem itemAt(self, int) -> QLayoutItem getItemPosition(self, int) -> Tuple[int, QFormLayout.ItemRole] setItem(self, int, QFormLayout.ItemRole, QLayoutItem) QGridLayout 应用场景 网格布局 取可用空间(通过其父布局或parentWidget())，将其划分为行和列 并将其管理的每个窗口小控件放入正确的单元格中。 每列/行具有最小宽度和拉伸系数 最小宽度是使用 set XXX MinimumWidth() 拉伸因子使用 set XXX Stretch() 功能作用 构造函数 QGridLayout(QWidget) QGridLayout() 元素操作 控件 addWidget(self, QWidget) addWidget(self, QWidget, int row, int col, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) addWidget(self, QWidget, int fromRow, int fromCol, int rowSpan, int colSpan, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) 布局 addLayout(self, QLayout, int row, int col, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) addLayout(self, QLayout, int fromRow, int fromCol, int rowSpan, int colSpan, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.Alignment()) 获取 位置获取 getItemPosition(self, int) -> Tuple[int, int, int, int] 条目获取 itemAtPosition(int row，int column) 列宽/行高和拉伸系数 setColumnMinimumWidth(int column，int minSize) columnMinimumWidth(int column) -> int setColumnStretch(int column，int stretch) columnStretch(int column) -> int setRowMinimumHeight(int row，int minSize) rowMinimumHeight(int row) -> int setRowStretch(int row，int stretch) rowStretch(int row) -> int 间距 setVerticalSpacing(int spacing) verticalSpacing() -> int setHorizontalSpacing(int spacing) horizontalSpacing() -> int setSpacing(int spacing) spacing() -> int 原点角 originCorner() -> Qt.Corner setOriginCorner(Qt.Corner corner) 补充 Qt.Corner Qt.TopLeftCorner Qt.TopRightCorner Qt.BottomLeftCorner Qt.BottomRightCorner 信息获取 cellRect(int row，int column) -> QRect columnCount() -> int rowCount() -> int QStackedLayout 应用场景 提供一个堆叠起来的布局, 在同一时刻只能显示一个控件 里面提供了相关方法, 可以切换控件 功能作用 构造函数 QStackedLayout() QStackedLayout(QWidget) QStackedLayout(QLayout) 添加子控件 addWidget(self, QWidget) -> int insertWidget(self, int, QWidget) -> int 获取子控件 widget(int index) -> QWidget 切换 setCurrentIndex(self, int) currentIndex(self) -> int setCurrentWidget(self, QWidget) currentWidget(self) -> QWidget 展示模式 setStackingMode(self, QStackedLayout.StackingMode) stackingMode(self) -> QStackedLayout.StackingMode 补充 QStackedLayout.StackOne 只有当前小控件可见。这是默认值。 QStackedLayout.StackAll 所有小部件都可见。当前控件显示在最前。 信号 currentChanged（int index） widgetRemoved（int index） 补充 QWidget.sizeHint() 合适的建议大小 size()的参照 并不一定是最终的size() 取值 无布局 无效值 isValid() 是False 有布局 一般是根据内容来确定, 会自动分配, 不要你管 可以选择重写此方法做测试, 在后续策略验证中做测试 QWidget.minimumSizeHint() 最小的建议大小 minimumSize()的参照 取值 无布局 无效值 isValid() 是False 有布局 一般是根据内容来确定, 会自动分配, 不要你管 layout 永远也不会把一个控件的尺寸设置到比 minimumSizeHint() 还小 除非 设置了最小尺寸 setMinimumSize() or 尺寸策略为Ignored 控件的尺寸策略 作用 一个控件的大小策略会告诉布局系统应该如何对它进行拉伸或收缩 Qt为它所有的内置控件都提供了合理的默认大小策略值 一个QSizePolicy包括 水平方向 策略 拉伸系数 垂直方向 策略 拉伸系数 注意 之前讲的拉伸系数, 是在拉伸策略设置了可以被拉伸为前提 策略取值 QSizePolicy.Fixed widget 的实际尺寸只参考 sizeHint() 的返回值，不能伸展（grow）和收缩（shrink） QSizePolicy.Minimum  可以伸展和收缩，不过sizeHint() 的返回值规定了 widget 能缩小到的最小尺寸 QSizePolicy.Maximum 可以伸展和收缩，不过sizeHint() 的返回值规定了 widget 能伸展到的最大尺寸  QSizePolicy.Preferred 可以伸展和收缩，但没有优势去获取更大的 额外空间使自己的尺寸比 sizeHint() 的返回值更大 QSizePolicy.Expanding  可以伸展和收缩，它会尽可能多地去获取额外的空间，也就是比 Preferred 更具优势 QSizePolicy.MinimumExpanding 可以伸展和收缩，不过sizeHint() 的返回值规定了 widget 能缩小到的最小尺寸 它比 Preferred 更具优势去获取额外空间 QSizePolicy.Ignored 忽略sizeHint() 的作用 策略图示 使用方式 设置控件设置尺寸策略 setSizePolicy(self, QSizePolicy) setSizePolicy(self, QSizePolicy.Policy, QSizePolicy.Policy) 补充 QSizePolicy setHorizontalPolicy(self, QSizePolicy.Policy) setHorizontalStretch(self, int) setVerticalPolicy(self, QSizePolicy.Policy) setVerticalStretch(self, int) setRetainSizeWhenHidden(self, bool) setHeightForWidth(self, bool) expandingDirections(self) -> Qt.Orientations 尺寸约束 应用场景 布局对象对主控件的尺寸影响 使用方式 QLayout.setSizeConstraint(QLayout.SizeConstraint) QLayout.SizeConstraint QLayout.SetDefaultConstraint 主窗口最小值被设置为minimumSize()，即layout管理所需的最小尺寸，除非widget已经有最小的minimumSize尺寸。 QLayout.SetFixedSize 主窗口的大小被设定为sizeHint()刚好适配好的大小，并不能再被重新设定大小。 QLayout.SetMinimumSize 设定主窗口minimumSize为minimumSize()定义的，其不能再小 QLayout.SetMaximumSize 设定主窗口的最大尺寸maxmumSize到maxmumSize()函数确定的尺寸，其不能大于这个尺寸。 QLayout.SetMinAndMaxSize 设定主窗口的大小尺寸分别为minimumSize和maxmunSize QLayout.SetNoConstraint 主窗口不设定尺寸策略，保持用户设定的已有属性 10-样式控制 概念 Qss Qt Style Sheet Qt 样式表 用来自定义控件外观的一种机制 可以将其类比CSS; 但没有CSS强大 选择器少 属性少 有些属性仅适用部分控件 使用 局部设置 指定需要设置外观的控件, 调用该控件的setStyleSheet方法 widget.setStyleSheet(qss_sheet_str) 参考作用范围 控件本身 子控件 最终作用范围 通过选择器二次筛选 全局设置 指定全局的QApplication对象, 调用对应的setStyleSheet方法 app.setStyleSheet(qss_sheet_str) 参考作用范围 应用程序所有控件 最终作用范围 通过选择器二次筛选 注意 真实开发中, 如果对于大量qss描述, 会抽离到一个单独的.qss文件中; 到时在需要使用的地方进行读取 也可以将读取操作, 封装到一个工具类中 然后在需要使用的地方, 读取该字符串 QSS语法 组成 QSS选择器 作用 指明哪些控件会受到样式的作用 分类 通配符选择器 匹配所有控件 类型选择器 通过控件类型来匹配控件(包含子类) 控件类型 例如 QPushButton 匹配所有QPushButton或者其子类的控件实例 类选择器 通过控件类型来匹配控件(不包含子类) .控件类型 例如 .QPushButton 只匹配所有QPushButton控件, 不包含子类 ID选择器 通过objectName来匹配控件 objectName 例如 hehe 匹配所有objectName为hehe的控件 属性选择器 通过属性值来匹配控件 控件类型[属性名=\"属性值\"] 例如 QPushButton[notice_level=\"warning\"] 匹配所有QPushButton控件 并且 该控件的notice_level属性值为\"warning\" 后代选择器 通过父控件(直接或者间接)子控件来筛选控件 父控件 子控件 例如 QDialog QPushButton 只匹配所有QDialog中包含的QPushButton控件 直接 间接 子选择器 通过父控件的(直接)子控件来筛选控件 父控件>子控件 例如 QDialog>QPushButton 只匹配所有QDialog中包含的QPushButton控件 只能直接包含 子控件选择器 用来筛选一个复合控件上的子控件 复合控件::子控件 常用子控件 QCheckBox, QRadioButton ::indicator QComboBox ::drop-down QSpinBox, QDateEdit, QTimeEdit, QDateTimeEdit ::up-button ::down-button ::up-arrow ::down-arrow 注意 up-button 显示在 QSpinBox 里，它的 subcontrol-origin 是相对于 QComboBox 的 down-button 显示在 QSpinBox 里，它的 subcontrol-origin 是相对于 QComboBox 的 up-arrow 显示在 up-button 里，它的 subcontrol-origin 是相对于 up-button 的 down-arrwo 显示在 down-button 里，它的 subcontrol-origin 是相对于 down-button 的 QSlider ::groove ::handle ::add-page ::sub-page 注意 groove 显示在 QSlider 里，它的 subcontrol-origin 是相对于 QSlider 的 handle 显示在 groove 里，它的 subcontrol-origin 是相对于 groove 的 sub-page 显示在 groove 里，它的 subcontrol-origin 是相对于 groove 的 add-page 显示在 groove 里，它的 subcontrol-origin 是相对于 groove 的 handle, sub-page, add-page 虽然都显示在 groove 里，但是都可以把它们扩展到 groove 外 QProgressBar ::chunk QScrollBar ::sub-line, ::add-line ::sub-page, ::add-page ::up-arrow, ::down-arrow ::left-arrow, ::right-arrow QGroupBox ::title ::indicator QTableView ::item QHeaderView, QTableCornerButton ::section QTreeView ::item ::branch QHeaderView ::section QTabWidget QTabWidget::pane QTabWidget::tab-bar QTabBar::tab QTabBar::close-button QTabBar::tear QTabBar::scroller QTabBar QToolButton::left-arrow QTabBar QToolButton::right-arrow 注意 以上选择器分类可以组合使用, 使用逗号隔开即可 QSS伪状态 作用 限制控件只能在某种状态下, 被样式表作用 语法 选择器:伪状态 例如 QPushButton:hover 所有的QPushButton控件(或者子控件) 在被鼠标经过时, 才会让后续样式表作用 常见伪状态 :checked button控件被选中 :unchecked button控件未被选中 :indeterminate checkBox或者radioButton被部分选中 :hover 控件被鼠标放在上面 :pressed 控件被按下 :focus 控件获取焦点 :disabled 控件失效 :enabled 控件有效 :on 控件处于on状态 :off 控件处于off状态 注意 不同的控件可能有某种特定的伪状态, 无法通用, 具体查看官方文档 ! 可以否定 :!checked 没有被选中时 可以连接使用 :hover:checked 鼠标在上and被选中时 :hover:!checked 鼠标经过and没被选中时 QSS声明 指明会作用怎样的样式 语法 {key: value; key: value; } 基本声明 盒子模型 以边框border为基准 margin 外边距 padding 内边距 content 内容矩形 QSS控制 外边距margin 内边距padding 边框相关(Border) 边框 控件的边框就是围绕控件内容和内边距的一条或多条线 每个边框有 3 个方面 样式 宽度 颜色 qss 样式 四条线统一设置 border-style 上 右 下 左 四条线分开设置 border-top-style border-right-style border-bottom-style border-left-style 常用取值 none 定义无边框。 dotted 定义点状边框 dashed 定义虚线 solid 定义实线 double 定义双线 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值。 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值。 inset 定义 3D inset 边框。其效果取决于 border-color 的值。 outset 定义 3D outset 边框。其效果取决于 border-color 的值。 宽度 四条线统一设置 border-width 上 右 下 左 四条线分开设置 border-top-width border-right-width border-bottom-width border-left-width 常用取值 具体的数值 10px 2em 注: 一般 1em = 16px 颜色 四条线统一设置 border-color 四条线分开设置 border-top-color border-right-color border-bottom-color border-left-color 常用取值 color_name red yellow green cyan ... rgb_number rgb(255,0,255) hex_number 00ff00 边框圆角 四个边框统一设置 border-radius 圆角半径 四个边框分别设置 border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 常用取值 具体的像素值 边框图片 border-image url(图片路径) 四个图片裁剪值 重复 裁剪值 由四条线将图片裁剪为9份 上 距离上边的线 右 距离右边的线 下 距离下边的线 左 距离左边的线 重复 排除四个角, 其他部分的重复策略 round 平铺 repeat 重复 stretch 拉伸 border-image: url(../source/border_test.png) 30 30 30 30 repeat 注意 需要使用border-width辅助确定边框宽度 外边距(Margin) 统一设置 margin 上 右 下 左 分开设置 margin-top margin-right margin-bottom margin-left 常用取值 16px 1em 注意 resize调整的是包含外边距的尺寸 外边距变大, 边框以内尺寸会变小 内边距(Padding) 统一设置 padding 上 右 下 左 分开设置 padding-top padding-right padding-bottom padding-left 常用取值 16px 1em 背景(Background) background 在一个声明中, 设置所有的背景属性 组成 background-color background-image background-repeat background-origin background-position ... background-color 背景颜色 取值 颜色 background-image 背景图片 取值 url(图片路径) background-position 对齐方式 取值 top left right bottom background-origin 位置参照 取值 padding 默认 content border background-clip 背景裁剪 取值 padding 默认 content border background-repeat 平铺模式 取值 repeat-xy 默认。背景图像将在垂直方向和水平方向重复。 repeat-x 背景图像将在水平方向重复。 repeat-y 背景图像将在垂直方向重复。 no-repeat 背景图像将仅显示一次。 background-attachment 是否跟随控件多余部分滚动而滚动 取值 scroll 默认值。背景图像会随着页面其余部分的滚动而移动。 fixed 当页面的其余部分滚动时，背景图像不会移动。 字体(Font) 统一设置 font 分开设置 font-family 宋体 幼圆 隶书 ... font-size 16px 1em font-style normal 默认值.显示一个标准的字体样式。 italic 显示一个斜体的字体样式。 oblique 显示一个倾斜的字体样式。 font-weight normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100 200 300 400 500 600 700 800 900 文本(Text) color 字体颜色 最大最小 min-width min-height max-width max-height Subcontrol Subcontrol-Origin 定义在 parent widget 中绘制 subcontrol 的参考矩形，默认在 padding 的矩形中绘制 取值 margin border padding content Subcontrol-Position 指明具体要在这个参考矩形的哪个位置绘制 取值 水平 left center right 垂直 top center bottom Top Bottom和 Left Right position: relative; position: absolute; 微调 Subcontrol 的位置 例如 QSpinBox QSpinBox { padding-left: 10px;; padding-right: 10px; border:2px dotted green; border-radius: 25px; } QSpinBox::up-button { width: 50px; height: 50px; subcontrol-origin: padding; subcontrol-position: left center; left: 2px; image: url(up.png); } QSpinBox::up-button:hover { bottom: 5px; } QSpinBox::down-button { width: 50px; height: 50px; subcontrol-origin: margin; subcontrol-position: right center; right: 2px; image: url(down.png); } QSpinBox::down-button:hover { top: 5px; } - QCheckBox QCheckBox { color: gray; border: 10px double rgb(76, 76, 76); padding: 5px; } QCheckBox::indicator { subcontrol-origin: border; subcontrol-position: left center; background: white; border: 2px solid gray; } QCheckBox::indicator:checked { background: rgb(76, 76, 76); } - QComboBox QComboBox { color: gray; border: 6px solid lightgray; spacing: 10px; /* indicator 和 text 的间隔 */ padding: 10px; } ​ QComboBox::drop-down { width: 15px; height: 10px; subcontrol-origin: border; subcontrol-position: bottom center; background: white; border: 2px dotted rgb(170, 170, 170); border-radius: 3px; } ​ QComboBox::drop-down:hover { background: lightgray; } ​ QComboBox::drop-down:on { background: gray; top: 1px; left: 1px; } - ... - 额外了解 - 渐变色 - 线性渐变 - qlineargradient(x1:0, y1:0, x2:1, y2:1,stop:0 white, stop: 0.4 gray, stop:1 green) - 图示 - 辐射渐变 - qradialgradient(cx:0.7, cy:0.7, radius:0.5, fx:0.5, fy:0.5, stop:0 red, stop:1 orange) - 图示 - 角度渐变 - qconicalgradient(cx:0.5, cy:0.5, angle:10, stop:0 red, stop:1 orange) - 图示 - 更多属性描述 - https://doc.qt.io/qt-5/stylesheet-reference.html 语法 选择器[:伪状态] { 声明 } 注意 级联 QSS可以在QApplication、父控件、子控件中设置 一个控件的最终样式, 会受到父控件和QApplication的影响 冲突 如果一个控件, 作为后代控件, 被多个祖先控件影响 则会不同属性产生叠加, 相同属性产生覆盖 看特异 例子1 QPushButton#okButton { color: gray } QPushButton { color: red } 例子2 QPushButton:hover { color: white } QPushButton { color: red } 例子3 QPushButton:enabled { color: red } QPushButton:hover { color: white } 例子4 QPushButton { color: red } QAbstractButton { color: gray } 案例 常用控件效果 QPushButton 特效 QPushButton{ color: qlineargradient(x1:0, y1:0, x2:1, y2:1,stop:0 white, stop: 0.4 red, stop:1 black); border:2px solid red; border-top-left-radius:50%; border-top-right-radius:50%; border-bottom-left-radius:10px; border-bottom-right-radius:10px } ​ QPushButton:hover{ color: qlineargradient(x1:0, y1:0, x2:1, y2:1,stop:0 white, stop: 0.4 green, stop:1 black); border:5px dotted green; border-top-left-radius:50%; border-top-right-radius:50%; border-bottom-left-radius:10px; border-bottom-right-radius:10px } ​ QPushButton:pressed{ font-size: 26px; border:10px double orange; border-radius: 30px; border-top-right-radius:4px } QCommandLinkButton 同上 修改Icon是使用 setIcon(QIcon) 方法 QRadioButton 特效 QRadioButton { padding-left: 10px; spacing: 60px; color: red; font-size: 20px; border: 1px double red; border-radius: 40px; } QRadioButton::indicator { width: 35px; height: 30px; } QRadioButton::indicator::unchecked { image: url(close_pic.png); } QRadioButton::indicator::checked { image: url(open_pic.png); } QCheckBox 特效 QCheckBox { padding-left: 10px; spacing: 60px; color: red; font-size: 20px; border: 1px double red; border-radius: 40px; } QCheckBox::indicator { width: 35px; height: 30px; } QCheckBox::indicator:unchecked { image: url(close_pic.png); } QCheckBox::indicator:indeterminate { image: url(mid_pic.png); } QCheckBox::indicator:checked { image: url(open_pic.png); } 素材 QLineEdit 特效 QLineEdit { border: 6px solid rgb(41, 57, 85); border-radius: 10px; background: white; selection-background-color: green; font-size: 14px ; } QLineEdit[echoMode=\"2\"] { lineedit-password-character: 65; } QLineEdit[readOnly=\"true\"] { background-color: gray; } QLineEdit:hover { border: 1px solid blue; } QTextEdit 特效 QTextEdit { border-radius: 20px; padding-top: 10px; padding-left: 30px; border-image: url(source/input_back.jpg); selection-background-color: green; font-size: 14px ; } QSpinBox 特效 QSpinBox { padding-left: 10px;; padding-right: 10px; border:2px dotted green; border-radius: 25px; } QSpinBox::up-button { width: 50px; height: 50px; subcontrol-origin: padding; subcontrol-position: left center; left: 2px; border-image: url(up.png); } QSpinBox::up-button:hover { bottom: 5px; } QSpinBox::down-button { width: 50px; height: 50px; subcontrol-origin: margin; subcontrol-position: right center; right: 2px; border-image: url(down.png); } QSpinBox::down-button:hover { top: 5px; } QComboBox 特效 QComboBox { color:red; selection-background-color: orange; min-height: 40px; min-width: 80px; } QComboBox QAbstractItemView { font: 14px; selection-color: white; selection-background-color: rgb(80, 80 80); background-color: orange; } QComboBox QAbstractItemView::item { color: green; } QComboBox::drop-down { background-color: cyan; } QComboBox::down-arrow { image: url(../source/down.png); width: 20px; height: 20px; } QSlider 特效 QSlider::groove:Horizontal { background:lightgray; height:16px; margin-left: -10px; margin-right: -10px; margin-top: -5px; margin-bottom: -5px; } QSlider::handle:Horizontal { border-image: url(../source/hk.png); height: 60px; width:30px; } QSlider::add-page:Horizontal { background-color: rgb(87, 97, 106); height:4px; } QSlider::sub-page:Horizontal { background-color:qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 cyan, stop:1 blue); height:4px; } QProgressBar 特效 QProgressBar { border: 2px solid gray; border-radius: 5px; text-align: center; color: yellow; font-size: 20px; background-color: orange; } QProgressBar::chunk { background-color: green; width: 10px; margin: 0.5px; } ... 11-设计工具-QtDesigner 搭建GUI界面的方式 纯手码 一行一行的通过手写代码来实现上述效果 特点 工作量较大 新手会把代码结构搞的特别混乱 手码+设计工具 通过可视化的设计工具，来按照所见即所得的方式进行设计界面，然后“自动转换成代码”或者直接进行使用 特点 直观，高效 鼠标拖拖拖，点点点就可以搞定 工作量小，方便修改调试 界面和逻辑分离 正规开发中，使用此种方式 QtDesigner介绍 Qt Designer中的操作方式十分灵活，其通过拖拽的方式放置控件可以随时查看控件效果 并可预览效果 Qt Designer的设计符合MVC的架构，实现了视图和逻辑的分离，从而实现了开发的便捷 设计出来的用户界面能够在多种平台上使用 Qt Designer生成的.ui文件（实质上是XML格式的文件） 可以直接使用 from PyQt5.uic import loadUi loadUi(\"login.ui\", self) 也可以通过pyuic5工具转换成.py文件 PyQt中关于QtDesigner的使用, 和PyCharm的配置 辅助工具安装 pip install PyQt5-tools -i https://pypi.douban.com/simple 使用演示 设计工具 快速搭建一个简易的登录界面 安装位置 \\site-packages\\pyqt5-tools\\designer.exe ui转py pyuic5 $FileName$ -o ui_$FileNameWithoutExtension$.py -x 安装位置 \\Python36\\Scripts\\pyuic5.exe qrc资源转换 pyrcc5 $FileName$ -o $FileNameWithoutExtension$_rc.py 安装位置 \\Python36\\Scripts\\pyrcc5.exe PyCharm外部工具配置 File Setting External Tools 具体使用 界面认识 创建界面 主界面 常用操作 控件 增加控件 移动控件 删除控件 控件之间的父子关系 控件属性 修改 新增 样式表 资源使用 加载自定义控件(类型提升) 布局操作 文件使用 .ui直接使用 from PyQt5.uic import loadUi loadUi(\"login.ui\", self) 转成.py使用 根据保存的.ui文件, 生成.py文件 根据生成的.py文件, 创建另外一个.py文件进行加载ui 资源的处理 .qrc转换成.py 补全槽函数 注意事项 注意 不要直接修改界面文件.py 补充1-自定义信号 1. 信号的定义 在类的内部, 以类属性的形式定义 pyqtSignal(类型1, 类型2...) 重载版本 pyqtSignal([int],[str]) 例如 class Btn(QPushButton): doubleClick = pyqtSignal() doubleClick2 = pyqtSignal([int], [str]) 2. 槽函数的定义 普通函数 方法 3. 信号与槽的连接 信号.connect(槽函数) 注意 重载的信号选择问题 信号[类型] 4. 信号的发射 信号.emit(参数1, 参数2...) 注意 重载的信号选择问题 信号[类型] 注意 一个信号连接另外一个信号时, 必须保证参数类型和个数一致 装饰器自动连接信号与槽 QtCore.QMetaObject.connectSlotsByName(obj) 将obj内部的子孙对象的信号, 按照其objectName连接到相关的槽函数 借助装饰器装饰固定规则的槽函数即可 代码 @pyqtSlot() def onobjectName信号(): pass 等同于 obj.objectName.信号.connect(obj.objectName_信号) def objectName_信号(): pass 补充2-动画 功能作用 做一些过渡的动画效果 动画类别继承结构图 QAbstractAnimation QAnimationGroup QParallelAnimationGroup QSequentialAnimationGroup QPauseAnimation QVariantAnimation QPropertyAnimation 类功能详解 基类功能 QAbstractAnimation 应用场景 所有动画共享的功能 继承此类, 实现一些自定义动画 功能作用 循环操作 setLoopCount(int loopCount) 设置动画循环次数 loopCount() -> int currentLoop() -> int 动画的当前循环 从0开始 currentLoopTime() -> int 当前循环内的时间 时间操作 duration() -> int 单次时长 totalDuration() -> int 动画总时长 currentTime() -> int 当前时长 动画方向 setDirection(QAbstractAnimation.Direction) direction() -> QAbstractAnimation.Direction 补充 QAbstractAnimation.Direction QAbstractAnimation.Forward 动画的当前时间随着时间而增加（即，从0移动到结束/持续时间）。 QAbstractAnimation.Backward 动画的当前时间随着时间减少（即，从结束/持续时间向0移动）。 动画状态 state() -> QAbstractAnimation.State 补充 QAbstractAnimation.State QAbstractAnimation.Stopped QAbstractAnimation.Paused QAbstractAnimation.Running 常用操作 start(QAbstractAnimation.DeletionPolicy) QAbstractAnimation.DeletionPolicy QAbstractAnimation.KeepWhenStopped 停止时不会删除动画。 QAbstractAnimation.DeleteWhenStopped 停止时动画将自动删除。 pause() resume() stop() setCurrentTime(int) setPause(bool) 常用信号 currentLoopChanged(int currentLoop) directionChanged(QAbstractAnimation.Direction newDirection) finished() stateChanged(QAbstractAnimation.State newState, QAbstractAnimation.State oldState) 子类特定功能 QPropertyAnimation 直接父类: QVariantAnimation 设置时长 setDuration(int msecs) 开始和结束值 setStartValue(QVariant value) startValue() -> QVariant setEndValue(QVariant value) endValue() -> QVariant 关键值 setKeyValueAt(double step, QVariant value) keyValueAt(double step) -> QVariant setKeyValues(QVariantAnimation.KeyValues keyValues) keyValues() -> QVariantAnimation.KeyValues 动画曲线 setEasingCurve(self, Union[QEasingCurve, QEasingCurve.Type]) easingCurve() -> Union[QEasingCurve, QEasingCurve.Type] 取值 https://doc.qt.io/qt-5/qeasingcurve.html#Type-enum 应用场景 属性动画 用于实现某个属性值从x到y的动画变化 功能作用 构造动画对象并设置目标属性 方式1 QPropertyAnimation(parent: QObject = None) setTargetObject(self, QObject) targetObject(self) setPropertyName(self, Union[QByteArray, bytes, bytearray]) propertyName(self) -> QByteArray 方式2 QPropertyAnimation(QObject, Union[QByteArray, bytes, bytearray], parent: QObject = None) 常用属性 geometry pos size windowOpacity 设置开始值和结束值 setStartValue(self, Any) setEndValue(self, Any) setKeyValueAt(self, float, Any) setKeyValues(self, object) 设置动画时长 setDuration(int mesc) 设置动画曲线 setEasingCurve(self, Union[QEasingCurve, QEasingCurve.Type]) 取值 https://doc.qt.io/qt-5/qeasingcurve.html#Type-enum 启动动画 start() QPauseAnimation 暂停动画, 在串行动画中使用 setDuration(int msecs) 设置暂停时长 动画组 应用场景 可以将一组动画, 同时播放或者按顺序播放 基类共性功能 QAnimationGroup 添加动画 addAnimation(QAbstractAnimation animation) insertAnimation(int index, QAbstractAnimation animation) 移除动画 removeAnimation(QAbstractAnimation animation) 获取动画 animationAt(int index) -> QAbstractAnimation 获取并移除 takeAnimation(int index) -> QAbstractAnimation 动画个数 animationCount() -> int 清空动画 clear() 子类功能 并行动画 QParallelAnimationGroup 功能参照父类 只是添加的所有动画, 都是同时执行 串行动画 QSequentialAnimationGroup 功能参照父类 只是添加的所有动画, 都是串行顺序执行 子类特性功能 addPause(int msecs) -> QPauseAnimation insertPause(int index, int msecs) -> QPauseAnimation currentAnimation() -> QAbstractAnimation 信号 currentAnimationChanged(QAbstractAnimation current) 阶段综合案例 案例效果图 效果.gif 案例功能 注册界面 控件创建 布局管理 样式控制 菜单动画 对外接口 退出按钮点击 注册按钮点击 账号信息 密码信息 弹出 消失 登录界面 控件创建 布局管理 样式控制 菜单动画 加QQ群链接生成 http://qun.qq.com/join.html 对外接口 注册账号按钮点击 登录按钮点击 账号信息 密码信息 弹出 消失 计算器 控件创建 布局管理 样式控制 业务逻辑实现 界面之间的业务对接和数据传递 打包可执行文件 打包的意义 将 \"代码+资源+依赖+环境\" 打包成一个单独的文件(夹) 直接交付给没有安装任何环境的用户进行使用 常用的打包工具 py2exe Cx_Freeze PyInstaller PyInstaller 功能作用 将Python应用程序及其所有依赖项捆绑到一个包中 用户无需安装Python解释器或任何模块即可运行打包的应用程序 平台支持 PyInstaller针对Windows，Mac OS X和Linux进行了测试 但是，它不是交叉编译器 制作Windows应用程序，在Windows中运行PyInstaller 制作一个Linux应用程序，你可以在Linux等中运行它 安装 Python版本 Python 3.6.3 pip版本 pip-18.1 安装命令 pip install pyinstaller 测试版本 3.3.1 安装位置 C:\\Python\\Python36\\Scripts 成功测试 pyinstaller --version 使用 常用形式 pyinstaller [opts] main.py 参数 -F 打包成一个exe文件 -D 创建一个目录, 包含exe文件, 会有很多依赖 默认 -c 使用控制台 -w 使用窗口 PyQt5 视频小计 GUI样式设置 给项目文件统一设置字体样式QObject.qss //QObject.qss 为同目录下创建的格式文件， with open(\"QObject.qss\", \"r\") as f: qApp.setStyleSheet(f.read()) 匹配的QObject.qss QLabel{ font-size: 20px; color:red; } 匹配了不同ID的QObject.qss,搭配label.setObjectName(\"notice\")即可实现不同ID的对应 QLabel#notice{ font-size: 20px; color:red; } © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"PythonLibrary.html":{"url":"PythonLibrary.html","title":"PythonLibrary","keywords":"","body":"PythonLibrary 记录学习Python过程中所学习的一些库 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"syslibrary.html":{"url":"syslibrary.html","title":"Python sys","keywords":"","body":"sys库 sys模块包括了一组非常实用的服务，内含很多函数方法和变量，用来处理Python运行时配置以及资源，从而可以与前当程序之外的系统环境交互，如：python解释器。 常见函数列表： 函数 说明 dir(sys) dir()方法查看模块中可用的方法。注意：如果是在编辑器，一定要注意要事先声明代码的编码方式，否则中文会乱码。 sys.argv 实现从程序外部向程序传递参数 sys.exit([arg]) 程序中间的退出，arg=0为正常退出 sys.getdefaultencoding() 获取系统当前编码，一般默认为ascii sys.setdefaultencoding() 设置系统默认编码，执行dir(sys)时不会看到这个方法，在解释器中执行不通过，可以先执行 reload(sys) 再执行setdefaultencoding(‘utf8’)，将系统编码设置为utf8 sys.getfilesystemencoding() 获取文件系统编码方式，Windows下返回’mbcs’，mac下返回’utf-8’ sys.path 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到 sys.platform 获取当前系统平台。 sys.stdin sys.stdoutsys.stderr stdin，stdout，以及stderr变量包含与标准I/O流对应的流对象。如果需要更好地控制输出，而print不能满足要求，它们就是你所需要的。你也可以替换它们，重定向输出和输入到其它设备(device)，或者以非标准的方式处理它们。 sys.modules 是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快程序运行的速度。它拥有字典所拥有的一切方法。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"PIL.html":{"url":"PIL.html","title":"Python PIL","keywords":"","body":"Python库-PIL库介绍 PIL图像处理库中的基本概念介绍 通道（bands） 每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。 以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。 对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。 方法getbands()的使用如下： 程序：from PIL import Image im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') im.getbands() 输出：('R', 'G', 'B') 程序：im_bands = im.getbands() len(im_bands) 输出：3 程序：print im_bands[0] 输出：R 程序：print im_bands[1] 输出：G 程序：print im_bands[2] 输出：B 模式（mode） 图像的模式定义了图像的类型和像素的位宽。当前支持如下模式： getpixel(0,0)[坐标] 1 1位像素，表示黑和白，但是存储的时候每个像素存储为8bit,模式“1”为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。 L 1模式也是八位一个像素，只是值不是0就是255，非黑即白 L模式八位一个像素，值除了有0和255外，还有很多中间值表示灰色，所以称为灰度模式(L = R * 299/1000 + G * 587/1000+ B * 114/1000) P 8位像素，使用调色板映射到其他模式。 RGB 3x8位像素，为真彩色。 RGBA 4x8位像素，有透明通道的真彩色。 CMYK 4x8位像素，颜色分离。模式“CMYK”为32位彩色图像，它的每个像素用32个bit表示。模式“CMYK”就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：Key Plate(blacK) = 定位套版色（黑色）。C = 255 - RM = 255 - GY = 255 - BK = 0 YCbCr 3x8位像素，彩色视频格式。模式“YCbCr”为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。模式“RGB”转换为“YCbCr”的公式如下：Cb：反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。Cr：反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。 I 模式“I”为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。I = R 299/1000 + G 587/1000 + B * 114/1000模式“I”与模式“L”的结果是完全一样，只是模式“L”的像素是8bit，而模式“I”的像素是32bit。 F 32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。 属性mode的使用方法： 程序：from PIL importImage im =Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') im.mode 输出：(800, 450) 程序：md = im.mode print md 输出：RGB 尺寸（size） 通过size属性可以获取图片的尺寸。这是一个二元组，包含水平和垂直方向上的像素数。 属性size的使用方法： 程序：from PIL importImage im =Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') im.size 输出：(800, 450) 程序：im_size = im.size print im_size[0] 输出：800 程序：print im_size[1] 输出：450 坐标（coordinate system） PIL使用笛卡尔像素坐标系统，坐标(0，0)位于左上角。注意：坐标值表示像素的角；位于坐标（0，0）处的像素的中心实际上位于（0.5，0.5）。 坐标经常用于二元组（x，y）。长方形则表示为四元组，前面是左上角坐标。例如，一个覆盖800x600的像素图像的长方形表示为（0，0，800，600）。 调色板（palette） 调色板模式 (\"P\")使用一个颜色调色板为每个像素定义具体的颜色值 信息（info） 使用info属性可以为一张图片添加一些辅助信息。这个是字典对象。加载和保存图像文件时，多少信息需要处理取决于文件格式。 程序：from PIL import Image im =Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') print(im.info) 输出：{'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)} 程序：im_info = im.info print(im_info) 输出：{'jfif_version':(1, 1), 'jfif': 257, 'jfif_unit': 1, 'jfif_density': (96, 96), 'dpi': (96, 96)} 程序：print im_info['jfif_version'] 输出：(1, 1) 程序：print im_info['jfif'] 输出：257 滤波器（filters） 对于将多个输入像素映射为一个输出像素的几何操作，PIL提供了4个不同的采样滤波器： NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值。注意：PIL的当前版本，做下采样时该滤波器使用了固定输入模板。 ANTIALIAS：平滑滤波。这是PIL 1.1.3版本中新的滤波器。对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值。在当前的PIL版本中，这个滤波器只用于改变尺寸和缩略图方法。 注意：在当前的PIL版本中，ANTIALIAS滤波器是下采样（例如，将一个大的图像转换为小图）时唯一正确的滤波器。BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的。 Image模块中的方法resize()和thumbnail()用到了滤波器。 方法resize()的使用如下： 方法resize()的定义为： resize(size, filter=None)=> image 程序：from PIL import Image im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') print(im.size) 输出：(800, 450) 程序：im_resize = im.resize((256,256)) im_resize.size 输出：(256, 256) 对参数filter不赋值的话，方法resize()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现： >>>im_resize0 = im.resize((256,256), Image.BILINEAR) >>>im_resize0.size (256, 256) >>>im_resize1 = im.resize((256,256), Image.BICUBIC) >>>im_resize1.size (256, 256) >>>im_resize2 = im.resize((256,256), Image.ANTIALIAS) >>>im_resize2.size (256, 256) 方法thumbnail ()的使用如下： 方法thumbnail ()的定义为：im.thumbnail(size, filter=None) >>>from PIL import Image >>> im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') >>>im.size (800, 450) >>>im.thumbnail((200,200)) >>>im.size (200,112) 这里需要说明的是，方法thumbnail()需要保持宽高比，对于size=(200,200)的输入参数，其最终的缩略图尺寸为(200, 112)。 对参数filter不赋值的话，方法thumbnail()默认使用NEAREST滤波器。如果要使用其他滤波器可以通过下面的方法来实现： >>> im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') >>>im.size (800, 450) >>> im.thumbnail((200,200),Image.BILINEAR) >>> im.size (200, 112) >>> im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') >>>im.size (800, 450) >>> im.thumbnail((200,200), Image.BICUBIC) >>> im.size (200, 112) >>> im= Image.open('D:\\\\Code\\\\Python\\\\test\\\\img\\\\1.jpg') >>>im.size (800, 450) >>> im.thumbnail((200,200), Image.ANTIALIAS) >>> im.size (200, 112) Image模块 可以实现对图像的基本操作：open、save、conver、show...等功能。 Image类中的函数 open 从文件加载图像，使用open函数，在Image模块： @winnerzr from PIL import Image # 调用库 im = Image.open(\"demo.jpg\") # 文件存在的路径 im.show() # 显示图片 KiteDocs：Image.open function SIGNATURE fp, mode=str RETURNS PngImageFile | JpegImageFile | GifImageFile HOW OTHERS USED THIS open(fp) DESCRIPTION Opens and identifies the given image file. This is a lazy operation; this function identifies the file, but the file remains open and the actual image data is not read from the file until you try to process the data (or call the :py:meth:~PIL.Image.Image.load method). See :py:func:~PIL.Image.new. param fp: A filename (string), pathlib.Path object or a file object. The file object must implement:py:meth:~file.read,:py:meth:~file.seek, and:py:meth:~file.tellmethods, and be opened in binary mode. param mode: The mode. If given, this argument must be \"r\". returns: An:py:class:~PIL.Image.Imageobject. exception IOError: If the file cannot be found, or the image cannot be opened and identified. new 给定一副尺寸和模式的图片，如果省略color参数，则创建的图片被黑色填充满，如果color参数是None值，则图片还没初始化。 使用给定的变量mode和size生成新的图像。Size是给定的宽/高二元组，这是按照像素数来计算的。对于单通道图像，变量color只给定一个值；对于多通道图像，变量color给定一个元组（每个通道对应一个值）。在版本1.1.4及其之后，用户也可以用颜色的名称，比如给变量color赋值为“red”。如果没有对变量color赋值，图像内容将会被全部赋值为0（为黑色）。如果变量color是空，图像将不会被初始化，即图像的内容全为0。这对向该图像复制或绘制某些内容是有用的。 from PIL import Image import matplotlib.pyplot as plt img_b = Image.new(\"RGB\",(32,32))#不指定color，则为黑色#000000 plt.imshow(img_b) plt.show() print(img_b.format)#python创建的图像，其格式为None img_r = Image.new(\"RGB\",(32,32),\"red\") plt.imshow(img_r) plt.show() img_g = Image.new(\"RGB\",(32,32),\"#00FF00\") plt.imshow(img_g) plt.show() 效果： KiteDocs：Image.new function SIGNATURE mode, size, color=0 RETURNS Image HOW OTHERS USED THIS new(mode, size, color) new(mode, size) new(mode, size, color) DESCRIPTION Creates a new image with the given mode and size. param mode: The mode to use for the new image. See:concept-modes. param size: A 2-tuple, containing (width, height) in pixels. param color: What color to use for the image. Default is black. If given, this should be a single integer or floating point value for single-band modes, and a tuple for multi-band modes (one value per band). When creating RGB images, you can also use color strings as supported by the ImageColor module. If the color is None, the image is not initialised. returns: An:py:class:~PIL.Image.Imageobject. blend Image.blend(image1,image2, alpha) ⇒ image 使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。 合成公式为：out = image1 (1.0 - alpha) + image2 alpha 若变量alpha为0.0，返回第一张图像的拷贝。若变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值无限制。 from PIL import Image im1 = Image.open(\"0000.jpg\") im2 = Image.open(\"00001.jpg\") print(im1.mode,im1.size) print(im2.mode,im2.size) im = Image.blend(im1, im2, 0.2) im.show() 补充透明度获取方法（包括更改透明度）： from PIL import Image img = Image.open(\"0000_switch.png\") img = img.convert('RGBA') # 修改颜色通道为RGBA x, y = img.size # 获得长和宽 # # 设置每个像素点颜色的透明度 for i in range(x): for k in range(y): color = img.getpixel((i, k)) color = color[:-1] + (0, ) # 将透明度设置为0 img.putpixel((i, k), color) img.save(\"0000_switch.png\") # 要保存为.PNG格式的图片才可以 img2 = Image.open(\"0000_switch.png\") img2.show() # color = img.getpixel((300,200)) 得到对应坐标的详细信息（R,G,B,alpha） # print(color) 输出： merge Image.merge(mode,bands) ⇒ image 合并类使用一些单通道图像，创建一个新的图像。变量bands为一个图像的元组或者列表，每个通道的模式由变量mode描述。所有通道必须有相同的尺寸。 变量mode与变量bands的关系： len(ImageMode.getmode(mode).bands)= len(bands) from PIL import Image im1 = Image.open(\"0000.jpg\") im2 = Image.open(\"0001.jpg\") r1,g1,b1 = im1.split() r2,g2,b2 = im2.split() print(r1.mode,r1.size,g1.mode,g1.size) print(r2.mode,r2.size,g2.mode,g2.size) new_im=[r1,g2,b2] print(len(new_im)) im_merge = Image.merge(\"RGB\",new_im) im_merge.show() Image类中的方法 save 保存文件 from PIL import Image im = Image.open(\"demo.jpg\") print(im) # 打印出原图片的详细信息 im.save(\"demo.png\") # 将\"0000.jpg\"保存为\"0000.png\" im = Image.open(\"demo.png\") # 打开新的png图片 print(im.format, im.size, im.mode) # 打印出转换后图片的相关信息（这里是格式，大小，色彩模式） KiteDocs：Image.save function SIGNATURE fp, format=None, **params **PARAMS Expand HOW OTHERS USED THIS save(fp) save(fp, format) save(fp, format, quality) save(fp, format) save(fp, quality) DESCRIPTION Saves this image under the given filename. If no format is specified, the format to use is determined from the filename extension, if possible. Keyword options can be used to provide additional instructions to the writer. If a writer doesn't recognise an option, it is silently ignored. The available options are described in the :doc:image format documentation for each writer. You can use a file object instead of a filename. In this case, you must always specify the format. The file object must implement the seek, tell, and write methods, and be opened in binary mode. param fp: A filename (string), pathlib.Path object or file object. param format: Optional format override. If omitted, the format to use is determined from the filename extension. If a file object was used instead of a filename, this parameter should always be used. param options: Extra parameters to the image writer. returns: None exception KeyError: If the output format could not be determined from the file name. Use the format option to solve this. exception IOError: If the file could not be written. The file may have been created, and may contain partial data. mode 图像的模式： im.mode ==> string 图像的模式，常见的mode有“L”表示灰度图像，“RGB”表示真彩色图像，“CMYK”表示出版图像，表示图像所使用的像素格式，见 convert 产生不同格式的图片并输出： from PIL import Image im = Image.open(\"0000.jpg\") # 读取图片 new_im = im.convert('1') # 输出格式为1的图片 print(new_im.mode) # 打印当前图像模式 new_im.show() # 显示转换之后的图片 在数字图像处理中，针对不同的图像格式有其特定的处理算法。所以，在做图像处理之前，我们需要考虑清楚自己要基于哪种格式的图像进行算法设计及其实现。 对于彩色图像，不管其图像格式是PNG，还是BMP，或者JPG，在PIL中，使用Image模块的open()函数打开后，返回的图像对象的模式都是“RGB”。而对于灰度图像，不管其图像格式是PNG，还是BMP，或者JPG，打开后，其模式为“L”。 KiteDocs：Image.convert function SIGNATURE mode=None, matrix=None, dither=None, palette=0, colors=256 RETURNS Image | JpegImageFile | PngImageFile | DibImageFile | Jpeg2KImageFile HOW OTHERS USED THIS convert(mode) DESCRIPTION Returns a converted copy of this image. For the \"P\" mode, this method translates pixels through the palette. If mode is omitted, a mode is chosen so that all information in the image and the palette can be represented without a palette. The current version supports all possible conversions between \"L\", \"RGB\" and \"CMYK.\" The matrix argument only supports \"L\" and \"RGB\". When translating a color image to black and white (mode \"L\"), the library uses the ITU-R 601-2 luma transform: L = R * 299/1000 + G * 587/1000 + B * 114/1000 The default method of converting a greyscale (\"L\") or \"RGB\" image into a bilevel (mode \"1\") image uses Floyd-Steinberg dither to approximate the original image luminosity levels. If dither is NONE, all non-zero values are set to 255 (white). To use other thresholds, use the :py:meth:~PIL.Image.Image.point method. param mode: The requested mode. See:concept-modes. param matrix: An optional conversion matrix. If given, this should be 4- or 12-tuple containing floating point values. param dither: Dithering method, used when converting from mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\". Available methods are NONE or FLOYDSTEINBERG (default). param palette: Palette to use when converting from mode \"RGB\" to \"P\". Available palettes are WEB or ADAPTIVE. param colors: Number of colors to use for the ADAPTIVE palette. Defaults to 256. rtype: :py:class:~PIL.Image.Image returns: An:py:class:~PIL.Image.Imageobject. format im.format==> string or none 这个属性可以识别图像来源，如果图像不是从文件读取它的值就是None。 from PIL import Image im = Image.open(\"0000.jpg\") print(im.format) # 打印出格式信息 im.show() 输出： size im.size ==> (width, height) 图像的尺寸，按照像素数计算，它的返回值为宽度和高度的二元组（width，height） from PIL import Image im = Image.open(\"0000.jpg\") print(im.size) # 打印出尺寸信息 im.show() palette im.palette ==> palette or None 颜色调色板表格。如果图像的模式是“P”，则返回ImagePalette类的实例；否则，将为None。 from PIL import Image im = Image.open(\".jpg\") print(im.palette) 输出： 对图像进行convert之后： from PIL import Image im = Image.open(\"0000.jpg\") print(im.palette) new_im = im.convert('P') print(new_im.mode) print(new_im.palette) 输出： info im.info ==》dictionary 存储图像相关数据的字典。文件句柄使用该字典传递从文件中读取的各种非图像信息。大多数方法在返回新的图像时都会忽略这个字典；因为字典中的键并非标准化的，对于一个方法，它不能知道自己的操作如何影响这个字典。如果用户需要这些信息，需要在方法open()返回时保存这个字典。 from PIL import Image im = Image.open(\"0000.jpg\") print(im.info) copy im.copy() ==>image 拷贝这个图像。如果用户想粘贴一些数据到这张图，可以使用这个方法，但是原始图像不会受到影响。 from PIL import Image im = Image.open(\"0000.jpg\") im_copy = im.copy() corp im.corp(box) ==> image 从当前的图像中返回一个矩形区域的拷贝。变量box是一个四元组，定义了左、上、右和下的像素坐标。用来表示在原始图像中截取的位置坐标，如box(100,100,200,200)就表示在原始图像中以左上角为坐标原点，截取一个100*100（像素为单位）的图像，为方便理解，如下为示意图box（b1,a1,b2,a2）。作图软件为Visio2016。这是一个懒操作。对源图像的改变可能或者可能不体现在裁减下来的图像中。为了获取一个分离的拷贝，对裁剪的拷贝调用方法load()。 from PIL import Image im = Image.open(\"0000.jpg\") box = (300, 100, 700, 700) ##确定拷贝区域大小 region = im.crop(box) ##将im表示的图片对象拷贝到region中，大小为box region.show() paste im.paste(image,box) 将一张图粘贴到另一张图像上。变量box或者是一个给定左上角的2元组，或者是定义了左，上，右和下像素坐标的4元组，或者为空（与（0，0）一样）。如果给定4元组，被粘贴的图像的尺寸必须与区域尺寸一样。如果模式不匹配，被粘贴的图像将被转换为当前图像的模式。 from PIL import Image im = Image.open(\"0000.jpg\") box=[0,0,100,100] im_crop = im.crop(box) print(im_crop.size,im_crop.mode) im.paste(im_crop, (100,100)) ##(100,100,0,0) im.paste(im_crop, (400,400,500,500)) im.show() filter im.filter(filter) ==> image 返回一个使用给定滤波器处理过的图像的拷贝。具体参考图像滤波在ImageFilter 模块的应用，在该模块中，预先定义了很多增强滤波器，可以通过filter() 函数使用，预定义滤波器包括：BLUR、CONTOUR、DETAIL、EDGE_ENHANCE、EDGE_ENHANCE_MORE、EMBOSS、FIND_EDGES、SMOOTH、SMOOTH_MORE、SHARPEN。其中BLUR就是均值滤波，CONTOUR找轮廓，FIND_EDGES边缘检测，使用该模块时，需先导入。 from PIL import Image from PIL import ImageFilter ## 调取ImageFilter imgF = Image.open(\"0000.jpg\") bluF = imgF.filter(ImageFilter.BLUR) ##均值滤波 conF = imgF.filter(ImageFilter.CONTOUR) ##找轮廓 edgeF = imgF.filter(ImageFilter.FIND_EDGES) ##边缘检测 imgF.show() bluF.show() conF.show() edgeF.show() split im.split() ⇒ sequence 返回当前图像各个通道组成的一个元组。例如，分离一个“RGB”图像将产生三个新的图像，分别对应原始图像的每个通道（红，绿，蓝）。 from PIL import Image im = Image.open(\"0000.jpg\") r,g,b = im.split() print(r.mode) print(r.size) print(im.size) r.show() # g.show() # b.show() rotate im.rotate(angle) ⇒ image im.rotate(angle,filter=NEAREST, expand=0) ⇒ image 返回一个按照给定角度顺时钟围绕图像中心旋转后的图像拷贝。变量filter是NEAREST、BILINEAR或者BICUBIC之一。如果省略该变量，或者图像模式为“1”或者“P”，则默认为NEAREST。变量expand，如果为true，表示输出图像足够大，可以装载旋转后的图像。如果为false或者缺省，则输出图像与输入图像尺寸一样大。 from PIL import Image im = Image.open(\"0000.jpg\") im_45 = im.rotate(45) im_30 = im.rotate(30, Image.NEAREST,1) print(im_45.size,im_30.size) im_45.show() im_30.show() seek im.seek(frame) 在给定的文件序列中查找指定的帧。如果查找超越了序列的末尾，则产生一个EOFError异常。当文件序列被打开时，PIL库自动指定到第0帧上。 from PIL import Image im_gif = Image.open(\"0000.gif\") print(im_gif.mode) im_gif.show() ##第0帧 im_gif.seek(3) im_gif.show() im_gif.seek(9) im_gif.show() © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"numpy.html":{"url":"numpy.html","title":"Python Numpy","keywords":"","body":"Numpy 简介 导入numpy Numpy是Python的一个重要的第三方库，很多其他科学计算的第三方库都是以Numpy为基础建立的。 Numpy的一个重要特性是它的数组计算。 在使用Numpy之前，我们需要导入numpy包： In [1]: from numpy import * 使用前一定要先导入 Numpy 包，导入的方法有以下几种： import numpy import numpy as np from numpy import * from numpy import array, sin 数组上的数学操作 前言： python中用列表保存一组值，可将列表当数组使用。 python中的array模块不支持多维数组，且没有科学运算函数，不适合做矩阵科学运算。 numpy提供了ndarray对象，不仅可以存取数组，且拥有丰富的数组计算函数。 使用前先导入Numpy模块 数组的创建及使用 >>> x=np.array([[1.0,0.0,0.0],[0.,1.,2.]]) #定义了一个二维数组，大小为（2，3） >>> x array([[1., 0., 0.], [0., 1., 2.]]) >>> x.ndim #数组维度数 2 >>> x.shape #数组的维数，返回的格式(n,m),其中n为行数，m为列数 (2, 3) >>> x.size #数组元素的总数 6 >>> x.dtype #数组元素类型 dtype('float64') #64位浮点型 >>> x.itemsize #每个元素占有的字节大小 8 >>> x.data #数组元素的缓冲区 还有两种创建序列数组的函数arrange和linspace，和range函数类似，但它们都属于Numpy里面。 arange(a,b,c) 参数分别表示开始值，结束值，步长； linspace(a,b,c) 参数分别表示开始值，结束值，元素数量，还可以调用它们自身的方法reshape()指定形状； >>> arange(15).reshape(3,5) array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) >>> arange(10,30,5) array([10, 15, 20, 25]) >>> arange(0,2,0.3) array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) >>> linspace(0,2,9) # 0~2之间生成9个数字 array([0., 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 还有两种创建概率分布的形式创建ndarray数组。 高斯分布（正态分布） np.random.randn(shape)：生成对应形状（shape）的高斯分布 np.random.normal(loc, scale, size)：生成均值为loc，标准差为scale，形状（shape）为size的高斯分布 均匀分布 np.random.rand(shape)：生成对应形状（shape）的均匀分布 np.random.uniform(low, high, size)：生成一个从[low, high)中随即采样的，样本数量为size的均匀分布 >>> a = np.random.randn(10) # 长度为10的一个一维数组 >>> a array([0.12939473,0.43128511,1.20540157,0.54083603,0.80768359,-1.24217976, -0.9713093 , 1.43538807, -1.07227227, -1.27176462]) >>> b = np.random.normal(0, 1, (2,4)) # 均值为0，方差为1，形状为（2，4）的二维数组 >>> b array([[ 0.4132305 , -2.06728849, 1.15189397, -1.11201615],[ 0.39955198, -0.89664908, -0.61361683, -0.13166113]]) >>> c = np.random.rand(2,3) # 生成一个形状为（2，3）的均匀分布二维数组 >>> c array([[0.57091351, 0.39960244, 0.77019683],[0.11316102, 0.59354993, 0.37849038]]) >>> d = np.random.uniform(-1,1,10) >>> d array([-0.34374858,-0.27026865,0.27073922,-0.42654097,-0.38736897,0.16293278, -0.79578655, -0.04825995, 0.28444576, 0.99118406]) 特殊数组 zeros数组：全零数组，元素全为零。 ones数组：全1数组，元素全为1。 empty数组：空数组，元素全近似为0。 >>> zeros((3,4)) array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) >>> ones((2,3,4),dtype=int16) array([[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]], dtype=int16) >>> empty((5,3)) array([[6.23042070e-307, 1.42417221e-306, 1.37961641e-306], [1.11261027e-306, 1.11261502e-306, 1.42410839e-306], [7.56597770e-307, 6.23059726e-307, 1.42419530e-306], [7.56599128e-307, 1.11260144e-306, 6.89812281e-307], [2.22522596e-306, 2.22522596e-306, 2.56761491e-312]]) 数组索引 Numpy数组每个元素，每行元素，每列元素都可以用索引访问。 >>> c=arange(24).reshape(2,3,4) # reshape()改变数组形状 >>> print(c) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] >>> print(c[1,2,:]) [20 21 22 23] >>> print(c[0,1,2]) 6 数组运算 算术运算：数组的加减乘除以及乘方运算方式为，相应位置的元素分别进行运算。 >>> a=array([20,30,40,50]) >>> aa=arange(1,5) >>> a/aa array([20., 15., 13.33333333, 12.5]) >>> b=arange(4) >>> b array([0, 1, 2, 3]) >>> c=a-b >>> c array([20, 29, 38, 47]) >>> b**2 array([0, 1, 4, 9], dtype=int32) >>> A=array([[1,1],[0,1]]) >>> b=array([[2,0],[3,4]]) >>> A*b array([[2, 0],[0, 4]]) >>> A.sum() 3 >>> A.min() 0 >>> A.max() 1 逻辑运算 arr > a : 返回arr中大于a的一个布尔值数组 arr[arr>a] : 返回arr中大于a的数据构成的一维数组 np.all(): 括号内全为真则返回真，有一个为假则返回false np.any() : 括号内全为假则返回假，有一个为真则返回真 np.where(): 三元预算符, 判断同时赋值 如：np.where(arr>0, 1, 0) 复合逻辑运算： 与：np.logical_and(): 括号为一系列表达式 或：np.logical_or() 统计运算 统计指标函数：min, max, mean, median, var, std np.函数名 ndarray.方法名 axis参数：axis=0代表列，axis=1代表行 最大值最小值的索引函数： np.argmax(arr, axis=) np.argmin(arr, axis=) 数组的拷贝 数组的拷贝分浅拷贝和深拷贝两种，浅拷贝通过数组变量的赋值完成，深拷贝使用数组对象的copy方法。浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改。如下： >>> a=ones((2,3)) >>> a array([[1., 1., 1.],[1., 1., 1.]]) >>> b=a >>> b[1,2]=2 >>> a array([[1., 1., 1.],[1., 1., 2.]]) >>> b array([[1., 1., 1.],[1., 1., 2.]]) 深拷贝会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。如下： >>> a=ones((2,3)) >>> b=a.copy() >>> b[1,2]=2 >>> a array([[1., 1., 1.],[1., 1., 1.]]) >>> b array([[1., 1., 1.],[1., 1., 2.]]) 广播机制 numpy中不同维度的数组是可以进行算数运算的，只要满足广播机制即可。 广播机制: 1.数组拥有相同形状 --->（3，4）+（3，4） 2.当前维度相等 --->（3，4）+（4，） 3.当前维度有一个是1--->(3,1,5)+(1,3,5) 分割与合并 np.hstack((a,b))：按行合并，要求a和b的行数相同 np.vstack((a,b))：按列合并，要求a和b的列数相同 np.c_[a,b]：用法如同np.hstack((a,b)) np.r_[a,b]：用法如同np.vstack((a,b)) >>> a = np.array([1,2,3]) >>> b = np.array([4,5,6]) >>> a,b (array([1, 2, 3]), array([4, 5, 6])) >>> np.hstack((a,b)) array([1, 2, 3, 4, 5, 6]) >>> np.vstack((a,b)) array([[1, 2, 3],[4, 5, 6]]) np.concatenate((a,b), axis = 1)：按行合并，要求a和b的行数相同 np.concatenate((a,b), axis = 0)：按列合并，要求a和b的列数相同 注意：如 果 不 指 定 a x i s ， 则 默 认 a x i s = 0 ， 即 按 列 合 并 。并且一维数组只能按行合并如果不指定axis，则默认axis=0，即按列合并。并且一维数组只能按行合并}如果不指定axis，则默认axis=0，即按列合并。并且一维数组只能按行合并 >>> a = np.array([1,2,3] >>> b = np.array([4,5,6]) >>> np.concatenate((a,b),axis=0) array([1, 2, 3, 4, 5, 6]) >>> np.concatenate((a,b),axis=1) # a，b都是一维数组，只能按axis=0合并 Traceback (most recent call last): File \"\", line 1, in numpy.AxisError: axis 1 is out of bounds for array of dimension 1 >>> x = np.array([[1,2],[3,4]]) >>> y = np.array([[5,6]]) >>> np.concatenate((x,y),axis=0) array([[1, 2], [3, 4], [5, 6]]) >>> np.concatenate((x,y.T),axis=1) # y.T表示将y数组转置 array([[1, 2, 5], [3, 4, 6]]) np.split(arr, n)：n要么是整数，要么是列表，用来进行划分，n为整数时必须是能均匀划分 np.array_split(arr, n)：类似上面的用法，但是可以不均等划分 >>> x = np.arange(9.0) >>> np.split(x, 3) [array([ 0., 1., 2.]), array([ 3., 4., 5.]), array([ 6., 7., 8.])] >>> x = np.arange(8.0) >>> np.split(x, [3, 5, 6, 10]) [array([ 0., 1., 2.]), array([ 3., 4.]), array([ 5.]), array([ 6., 7.]), array([], dtype=float64)] >>> x = np.arange(8.0) >>> np.array_split(x, 3) [array([ 0., 1., 2.]), array([ 3., 4., 5.]), array([ 6., 7.])] >>> x = np.arange(7.0) >>> np.array_split(x, 3) [array([ 0., 1., 2.]), array([ 3., 4.]), array([ 5., 6.])] numpy降维 ravel()：返回一维数组，但是改变返回的一维数组内容后，原数组的值也会相应改变 flatten()：返回一维数组，改变返回的数组不影响原数组 >>> a array([[1, 2, 3], [7, 8, 9]]) >>> b array([[4, 5, 6], [1, 2, 3]]) >>> c = a.ravel() >>> c array([1, 2, 3, 7, 8, 9]) >>> d = b.flatten() >>> d array([4, 5, 6, 1, 2, 3]) >>> c[0]=100 >>> c array([100, 2, 3, 7, 8, 9]) >>> a array([[100, 2, 3], [ 7, 8, 9]]) >>> d[0]=100 >>> d array([[100, 100], [ 6, 1], [ 2, 3]]) >>> b array([[4, 5, 6], [1, 2, 3]]) 矩阵 创建矩阵 Numpy的矩阵对象与数组对象相似，主要不同之处在于，矩阵对象的计算遵循矩阵数学运算规律。矩阵使用matrix函数创建。 >>> A=matrix('1.0 2.0;3.0 4.0') >>> A matrix([[1., 2.], [3., 4.]]) >>> b=matrix([[1.0,2.0],[3.0,4.0]]) >>> b matrix([[1., 2.], [3., 4.]]) >>> type(A) 矩阵计算 矩阵的常用数学运算有转置，乘法，求逆等。 >>> A.T #转置 matrix([[1., 3.], [2., 4.]]) >>> x=matrix('5.0 7.0') >>> y=x.T >>> y matrix([[5.], [7.]]) >>> print(A*y) #矩阵乘法 [[19.] [43.]] >>> print(A.I) #逆矩阵 [[-2. 1. ] [ 1.5 -0.5]] Numpy线性代数相关函数 numpy.dot() 此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。 >>> a=np.array([[1,2],[3,4]]) >>> b=np.array([[11,12],[13,14]]) >>> np.dot(a,b) array([[37, 40], #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] [85, 92]]) numpy.inner() 此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。 >>> x=np.array([1,2,3]) >>> y=np.array([0,1,0]) >>> print(np.inner(x,y)) 2 # 等价于 1*0+2*1+3*0 numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。 #对二维数组（列表），就相当于矩阵乘法 >>> a=[[1,0],[0,1]] >>> b=[[4,1],[2,2]] >>> print(np.matmul(a,b)) [[4 1] [2 2]] #二维和一维运算 >>> a=[[1,0],[0,1]] >>> b=[1,2] >>> print(np.matmul(a,b)) [1 2] >>> print(np.matmul(b,a)) [1 2] #维度大于2的 >>> a=np.arange(8).reshape(2,2,2) >>> b=np.arange(4).reshape(2,2) >>> print(np.matmul(a,b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() 行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.det()函数计算输入矩阵的行列式。 >>> a=np.array([[1,2],[3,4]]) >>> print(np.linalg.det(a)) -2.0000000000000004 >>> b=np.array([[6,1,1],[4,-2,5],[2,8,7]]) >>> print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]] >>> print(np.linalg.det(b)) -306.0 >>> print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2)) -306 numpy.linalg.solve() 该函数给出了矩阵形式的线性方程的解。 例： x + y + z = 6 2y + 5z = -4 2x + 5y - z = 27 写成矩阵形势： 可表示为AX=B，即求X=A^(-1)B，逆矩阵可以用numpy.linalg.inv()函数来求 >>> x=np.array([[1,2],[3,4]]) >>> y=np.linalg.inv(x) >>> x array([[1, 2], [3, 4]]) >>> y array([[-2. , 1. ], [ 1.5, -0.5]]) >>> np.dot(x,y) array([[1.0000000e+00, 0.0000000e+00], [8.8817842e-16, 1.0000000e+00]]) 计算线性方程的解 a=np.array([[1,1,1],[0,2,5],[2,5,-1]]) print('数组a:') print(a) ainv=np.linalg.inv(a) print('a的逆矩阵') print(ainv) print('矩阵b:') b=np.array([[6],[-4],[27]]) print(b) print('计算：A^(-1)B:') x=np.linalg.solve(a,b) print(x) test © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"PythonArduino.html":{"url":"PythonArduino.html","title":"PythonArduino","keywords":"","body":"一、Use Python and arduino to connect LED This article will show you how to © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"conda.html":{"url":"conda.html","title":"PythonConda","keywords":"","body":"查看anaconda版本信息 conda --version ：查看版本信息。 升级相关 conda upgrade --all：升级所有工具包。 conda update conda：检查更新当前conda。 管理虚拟环境 使用anaconda可以为我们创建所需要的特定的虚拟环境。 conda create --name env_name python=xxx：创建你所需要的python虚拟环境。 激活环境 Windows：activate env_name：切换到所创建的python虚拟环境。 Mac/Linux：source activate env_name。 conda env list或conda info -e：查看所有的环境。 conda remove --name env_name --all：删除一个已有的python虚拟环境。 conda remove --name $your_env_name $package_name：不进入任何的虚拟环境，指定要删除的哪个环境的哪个包。 deactivate env_name：退出环境。 conda env export > environment.yml：分享环境，会在当前工作目录下生成一个。environment.yml文件，拿到environment.yml文件后，将该文件放在工作目录下，可以通过命令conda env create -f environment.yml从该文件创建环境。 conda常用命令 conda list：查看安装了哪些包。 conda install package_name(包名)：安装指定包。 使用Qtconsole 直接运行jupyter qtconsole（需要首先pip install jupyter）。 使用jupyter notebook 在任意文件夹中打开cmd：输入jupyter notebook，好处是生成的ipynb文件会保存在当前的文件夹中。 启动之后会打开一个网页 使用jupyterlab Jupyter Lab 的启用 和 Jupyter Notebook 方法一样，只需要将输入的 jupyter notebook 换成 jupyter lab 即可。 我们点击 jupyterlab 下面的 Launch ，会在默认浏览器（我这里是 Chrome）打开 http://localhost:8888/lab 这样一个东东，这里就可以输入 Python 代码啦，来一句 Hello World 吧。 友情链接：CSDN 彻底卸载anaconda 打开anaconda prompt： 输入conda install anaconda-clean 输入anaconda-clean --yes 通过Uninstall-Anaconda3.exe 急救方法 终端用命令anaconda-navigator运行anaconda © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"PythonMachineLearn.html":{"url":"PythonMachineLearn.html","title":"PythonMachineLearn","keywords":"","body":"Python机器学习 机器学习路线图： 机器学习开发流程图： 认识： 机器学习小白版： SKlearn SKlearn简介 scikit-learn，又写作sklearn，是一个开源的基于python语言的机器学习工具包。它通过NumPy, SciPy和Matplotlib等python数值计算的库实现高效的算法应用，并且涵盖了几乎所有主流机器学习算法。 SKlearn官网链接：http://scikit-learn.org/stable/index.html 在工程应用中，用python手写代码来从头实现一个算法的可能性非常低，这样不仅耗时耗力，还不一定能够写出构架清晰，稳定性强的模型。更多情况下，是分析采集到的数据，根据数据特征选择适合的算法，在工具包中调用算法，调整算法的参数，获取需要的信息，从而实现算法效率和效果之间的平衡。而sklearn，正是这样一个可以帮助我们高效实现算法应用的工具包。 sklearn有一个完整而丰富的官网，里面讲解了基于sklearn对所有算法的实现和简单应用。 scikit-learn 算法选择： 流程图隐含条件： 蓝色圆圈：判断条件 绿色圆圈：可供选择的算法 常用模块 sklearn中常用的模块有分类、回归、聚类、降维、模型选择、预处理。 分类：识别某个对象属于哪个类别，常用的算法有：SVM（支持向量机）、nearest neighbors（最近邻）、random forest（随机森林），常见的应用有：垃圾邮件识别、图像识别。 回归：预测与对象相关联的连续值属性，常见的算法有：SVR（支持向量机）、 ridge regression（岭回归）、Lasso，常见的应用有：药物反应，预测股价。 聚类：将相似对象自动分组，常用的算法有：k-Means、 spectral clustering、mean-shift，常见的应用有：客户细分，分组实验结果。 降维：减少要考虑的随机变量的数量，常见的算法有：PCA（主成分分析）、feature selection（特征选择）、non-negative matrix factorization（非负矩阵分解），常见的应用有：可视化，提高效率。 模型选择：比较，验证，选择参数和模型，常用的模块有：grid search（网格搜索）、cross validation（交叉验证）、 metrics（度量）。它的目标是通过参数调整提高精度。 预处理：特征提取和归一化，常用的模块有：preprocessing，feature extraction，常见的应用有：把输入数据（如文本）转换为机器学习算法可用的数据。 安装SKlearn scikit-learn需要： Python Numpy Scipy 安装时可以直接运行： pip install -U scikit-learn 其他命令： 更新pip： python -m pip install --upgrade pip 安装scipy： 在网址http://www.lfd.uci.edu/~gohlke/pythonlibs/ 中找到你需要的版本scipy 例如windows 64 位 Python2.7 对应下载:scipy-0.18.0-cp27-cp27m-win_amd64.whl cd 下载scipy 目录下，安装 pip install scipy-0.18.0-cp27-cp27m-win_amd64.whl 安装matplotlib： pip install matplotlib 安装numpy+mkl： 在网址http://www.lfd.uci.edu/~gohlke/pythonlibs/ 找到你需要的numpy+mkl版本 然后 cd 到numpy+mkl所在的目录下，安装 pip install numpy-1.11.1+mkl-cp27-cp27m-win_amd64.whl # 不同Python版本安装版本随之改变 pip install -U scikit-learn 要升级或卸载scikit-learn安装了python或者conda你不应该使用PIP命令。 conda： 升级scikit-learn：conda update scikit-learn 卸载scikit-learn：conda remove scikit-learn Python： 使用pip install -U scikit-learn安装或者使用pip uninstall scikit-learn卸载可能都没有办法更改有conda命令安装的sklearn。 官方文档中文版学习笔记： 官方文档中文版 监督学习： 1.1广义线性模型： 官网实例（翻译）： Linear Regression Example： 本例仅使用糖尿病数据集的第一个特征，以说明这种回归技术的二维图。在图中可以看到直线，显示了线性回归如何试图画出一条直线，使数据集中观察到的反应与线性近似预测的反应之间的残差平方和最小化。 还计算了系数、残差平方和和确定系数。 Out: Coefficients: [938.23786125] Mean squared error: 2548.07 //均方差 Coefficient of determination: 0.47 print(__doc__) # Code source: Jaques Grobler # License: BSD 3 clause import matplotlib.pyplot as plt import numpy as np from sklearn import datasets, linear_model from sklearn.metrics import mean_squared_error, r2_score # Load the diabetes dataset # 加载糖尿病数据集 diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True) # Use only one feature # 仅使用一个特征 diabetes_X = diabetes_X[:, np.newaxis, 2] # Split the data into training/testing sets diabetes_X_train = diabetes_X[:-20] diabetes_X_test = diabetes_X[-20:] # Split the targets into training/testing sets diabetes_y_train = diabetes_y[:-20] diabetes_y_test = diabetes_y[-20:] # Create linear regression object regr = linear_model.LinearRegression() # Train the model using the training sets regr.fit(diabetes_X_train, diabetes_y_train) # Make predictions using the testing set diabetes_y_pred = regr.predict(diabetes_X_test) # The coefficients print('Coefficients: \\n', regr.coef_) # The mean squared error print('Mean squared error: %.2f' % mean_squared_error(diabetes_y_test, diabetes_y_pred)) # The coefficient of determination: 1 is perfect prediction print('Coefficient of determination: %.2f' % r2_score(diabetes_y_test, diabetes_y_pred)) # Plot outputs # 绘图输出 plt.scatter(diabetes_X_test, diabetes_y_test, color='black') plt.plot(diabetes_X_test, diabetes_y_pred, color='blue', linewidth=3) plt.xticks(()) plt.yticks(()) plt.show() 无监督学习： 数学知识积累 经验贴 线性代数 1-1、标量 一个标量就是一个单独的数，一般用小写的变量名称表示。 1-2、向量 一个向量就是一列数，这些数是有序排列的。用过次序中的索引，我们可以确定每个单独的数。通常会赋予向量粗体的小写名称。当我们需要明确表示向量中的元素时，我们会将元素排列成一个方括号包围的纵柱： 我们可以把向量看作空间中的点，每个元素是不同的坐标轴上的坐标。 1-3、矩阵 矩阵是二维数组，其中的每一个元素被两个索引而非一个所确定。我们通常会赋予矩阵粗体的大写变量名称，比如A。 如果一个实数矩阵高度为m，宽度为n，那么我们说 $$ A\\epsilon R^{m*n} $$ 矩阵这东西在机器学习中就不要太重要了！实际上，如果我们现在有N个用户的数据，每条数据含有M个特征，那其实它对应的就是一个NM的矩阵呀；再比如，一张图由16x16的像素点组成，那这就是一个16x16的矩阵了。现在才发现，我们大一学的矩阵原理原来这么的有用！要是当时老师讲课的时候先普及一下，也不至于很多同学学矩阵的时候觉得莫名其妙了。 1-4、张量 几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。 例如，可以将任意一张彩色图片表示成一个三阶张量，三个维度分别是图片的高度、宽度和色彩数据。将这张图用张量表示出来，就是最下方的那张表格： 其中表的横轴表示图片的宽度值，这里只截取0~319；表的纵轴表示图片的高度值，这里只截取0~4；表格中每个方格代表一个像素点，比如第一行第一列的表格数据为[1.0,1.0,1.0]，代表的就是RGB三原色在图片的这个位置的取值情况（即R=1.0，G=1.0，B=1.0）。 当然我们还可以将这一定义继续扩展，即：我们可以用四阶张量表示一个包含多张图片的数据集，这四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。 张量在深度学习中是一个很重要的概念，因为它是一个深度学习框架中的一个核心组件，后续的所有运算和优化算法几乎都是基于张量进行的。 1-5、范数 有时我们需要衡量一个向量的大小。在机器学习中，我们经常使用被称为范数(norm) 的函数衡量矩阵大小。Lp 范数如下： 所以： 这里先说明一下，在机器学习中，L1范数和L2范数很常见，主要用在损失函数中起到一个限制模型参数复杂度的作用，至于为什么要限制模型的复杂度，这又涉及到机器学习中常见的过拟合问题。具体的概念在后续文章中会有详细的说明和推导，大家先记住：这个东西很重要，实际中经常会涉及到，面试中也常会被问到！！！ 1-6、特征分解 1-7、奇异值分解（Singular Value Decomposition，SVD） 1-8、Moore-Penrose伪逆 1-9、几种常用的距离 1、曼哈顿距离 from numpy import * vector1 = mat([1,2,3]) vector2 = mat([4,5,6]) print sum(abs(vector1-vector2)) 2、欧氏距离 from numpy import * vector1 = mat([1,2,3]) vector2 = mat([4,5,6]) print sqrt((vector1-vector2)*(vector1-vector2).T) 3、闵可夫斯基距离 4、切比雪夫距离 from numpy import * vector1 = mat([1,2,3]) vector2 = mat([4,5,6]) print sqrt(abs(vector1-vector2).max) 5、夹角余弦 from numpy import * vector1 = mat([1,2,3]) vector2 = mat([4,5,6]) print dot(vector1,vector2)/(linalg.norm(vector1)*linalg.norm(vector2)) 6、汉明距离 from numpy import * matV = mat([1,1,1,1],[1,0,0,1]) smstr = nonzero(matV[0]-matV[1]) print smstr 7、杰卡德相似系数 8、杰卡德距离 from numpy import * import scipy.spatial.distance as dist matV = mat([1,1,1,1],[1,0,0,1]) print dist.pdist(matV,'jaccard') 概率 3-1、使用概率的原因 3-2、随机变量 3-3、概率分布 3-4、条件概率 3-5、贝叶斯公式 期望、方差、协方差等主要反映数据的统计特征，机器学习的一个很大应用就是数据挖掘等，因此这些基本的统计概念也是很有必要掌握。另外，像后面的EM算法中，就需要用到期望的相关概念和性质。 3-6、期望 3-7、方差 3- 8、协方差 3-9、常见分布函数 1. 0-1分布 0-1分布是单个二值型离散随机变量的分布，其概率分布函数为： 2. 几何分布 3. 二项分布 4. 高斯分布 5. 指数分布 6.泊松分布 3-10、Lagrange乘子法 3-11、最大似然估计 信息论 信息论本来是通信中的概念，但是其核心思想“熵”在机器学习中也得到了广泛的应用。比如决策树模型ID3，C4.5中是利用信息增益来划分特征而生成一颗决策树的，而信息增益就是基于这里所说的熵。所以它的重要性也是可想而知。 4-1、熵 4-2、联合熵 4-3、条件熵 4-4、相对熵 4-5、互信息 4-6、最大熵模型 回归（Regression） 回归问题是针对于连续型变量的。 举个栗子：预测房屋价格 假设想要预测房屋价格，绘制了下面这样的数据集。水平轴上，不同房屋的尺寸是平方英尺，在竖直轴上，是不同房子的价格，单位时（千万$）。给定数据，假设一个人有一栋房子，750平方英尺，他要卖掉这栋房子，想知道能卖多少钱。 这个时候，监督学习中的回归算法就能派上用场了，我们可以根据数据集来画直线或者二阶函数等来拟合数据。 通过图像，我们可以看出直线拟合出来的150k,曲线拟合出来是200k,所以要不断训练学习，找到最合适的模型得到拟合数据（房价）。 回归通俗一点就是，对已经存在的点（训练数据）进行分析，拟合出适当的函数模型y=f(x)，这里y就是数据的标签，而对于一个新的自变量x，通过这个函数模型得到标签y。 分类（Classification） 和回归最大的区别在于，分类是针对离散型的，输出的结果是有限的。 举个栗子：估计肿瘤性质 假设某人发现了一个乳腺瘤，在乳腺上有个z肿块，恶性瘤是危险的、有害的；良性瘤是无害的。 假设在数据集中，水平轴是瘤的尺寸，竖直轴是1或0，也可以是Y或N。在已知肿瘤样例中，恶性的标为1，良性的标为0。那么，如下，蓝色的样例便是良性的，红色的是恶性的。 这个时候，机器学习的任务就是估计该肿瘤的性质，是恶性的还是良性的。 那么分类就派上了用场，在这个例子中就是向模型输入人的各种数据的训练样本（这里是肿瘤的尺寸，当然现实生活里会用更多的数据，如年龄等），产生“输入一个人的数据，判断是否患有癌症”的结果，结果必定是离散的，只有“是”或“否”。 所以简单来说分类就是，要通过分析输入的特征向量，对于一个新的向量得到其标签。 数学中一个字母上面的^符号 y的估计——————（统计学） 词汇积累 cheat-sheet： © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Python数据分析.html":{"url":"Python数据分析.html","title":"Python数据分析","keywords":"","body":"Data analysis learning 什么是数据分析： 数据分析是用适当的方法对收集来的大量数据进行分析,帮助人们做出判断，一遍采取适当行动 jupyter notebook © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ipythonmagic.html":{"url":"ipythonmagic.html","title":"IpythonMagic","keywords":"","body":"Ipython中的魔法命令 IPython中的魔法命令有很多魔法命令，能让我们更好的使用IPython，同时这魔法命令也能在JupyterNotebook中使用，因为后者是以前者为内核的。 命令 说明 %quickref 快速导引 %magic Magic Functions 详细说明 %fun? 获取具体帮助 %lsmagic 列出所有可⽤用 Magic Functions obj?, obj?? 获取对象信息，?? 返回更详细的信息，⽐比如源码 ?obj.abc 返回对象匹配的成员，⽐比如: str.is* !, !! 执⾏行系统命令，捕获输出结果为字符串或列表 %doctest_mode 切换 shell 提示示样式，包括提示示符、输出等设置 %pprint Pretty-Print 开关 %bookmark 目录书签 %cd, %pwd, _dh 工作目录 %dirs, %popd, %pushd 目录栈 %ed, %edit 使用编辑器打开文件 %debug 进入最后一次异常场景，pdb.pm() %pdb pdb开关，出现异常时是否进入调试模式 %pdoc 查看对象文档 %psource 查看对象源码 %pyfile 查看包含指定对象的文件内容 %pycat 按页查看文件 %run 运行指定文件 %prun, %time, %timeit 测试代码运行时间 %psearch 在当前名字空间按通配符搜索名字 %who,%whos 查看所有变量 %env 输出环境变量 %hist 查看历史变量 %reset 重置环境，移除所有名字 备注： %%表示多行模式，%仅指单行模式； 在 shell command 中可以用 $ name 引用 Python 变量名字，$$name 引用环境变量； 系统命名捕获可以直接赋值给某个名字，如 name = !unam； %ed: -n 跳转到指定行；-x 退出编辑器时不执行；-p 使⽤用上一次 ed 命令； %run: -n 设定 name 为⾮非 “main”；-i 引⼊入交互环境名字空间；-d 进⼊入调试模式。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2022-11-25 11:24:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}