# Numpy 简介

## 导入numpy

**Numpy**是**Python**的一个重要的第三方库，很多其他科学计算的第三方库都是以`Numpy`为基础建立的。

**Numpy**的一个重要特性是它的数组计算。

在使用**Numpy**之前，我们需要导入`numpy`包：

In [1]:

```python
from numpy import *
```

使用前一定要先导入 Numpy 包，导入的方法有以下几种：

```python
import numpy
import numpy as np
from numpy import *
from numpy import array, sin
```

## 数组上的数学操作

> 前言：
>
> `python`中用列表保存一组值，可将列表当数组使用。
>
> `python`中的`array`模块不支持多维数组，且没有科学运算函数，不适合做矩阵科学运算。
>
> `numpy`提供了`ndarray`对象，不仅可以存取数组，且拥有丰富的数组计算函数。
>
> 使用前先导入`Numpy`模块

### 数组的创建及使用

```python
>>> x=np.array([[1.0,0.0,0.0],[0.,1.,2.]]) #定义了一个二维数组，大小为（2，3）
>>> x
array([[1., 0., 0.],
       [0., 1., 2.]])
>>> x.ndim   #数组维度数
2
>>> x.shape    #数组的维数，返回的格式(n,m),其中n为行数，m为列数
(2, 3)
>>> x.size    #数组元素的总数
6
>>> x.dtype   #数组元素类型
dtype('float64')  #64位浮点型
>>> x.itemsize  #每个元素占有的字节大小
8
>>> x.data    #数组元素的缓冲区
<memory at 0x00000205227DAC18>
```

还有两种创建序列数组的函数`arrange`和`linspace`，和`range`函数类似，但它们都属于`Numpy`里面。

- `arange(a,b,c)` 参数分别表示开始值，结束值，步长；
- `linspace(a,b,c)` 参数分别表示开始值，结束值，元素数量，还可以调用它们自身的方法`reshape()`指定形状；

```python
>>> arange(15).reshape(3,5)
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> arange(10,30,5)
array([10, 15, 20, 25])
>>> arange(0,2,0.3)
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
>>> linspace(0,2,9) # 0~2之间生成9个数字
array([0., 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])
```

还有两种创建概率分布的形式创建`ndarray`数组。

### 高斯分布（正态分布）

> - `np.random.randn(shape)`：生成对应形状（shape）的高斯分布
> - `np.random.normal(loc, scale, size)`：生成均值为loc，标准差为scale，形状（shape）为size的高斯分布

### 均匀分布

> - `np.random.rand(shape)`：生成对应形状（shape）的均匀分布
> - `np.random.uniform(low, high, size)`：生成一个从[low, high)中随即采样的，样本数量为size的均匀分布

```python
>>> a = np.random.randn(10) # 长度为10的一个一维数组
>>> a
array([0.12939473,0.43128511,1.20540157,0.54083603,0.80768359,-1.24217976, -0.9713093 ,  1.43538807, -1.07227227, -1.27176462])
>>> b = np.random.normal(0, 1, (2,4)) # 均值为0，方差为1，形状为（2，4）的二维数组
>>> b
array([[ 0.4132305 , -2.06728849,  1.15189397, -1.11201615],[ 0.39955198, -0.89664908, -0.61361683, -0.13166113]])
>>> c = np.random.rand(2,3) # 生成一个形状为（2，3）的均匀分布二维数组
>>> c
array([[0.57091351, 0.39960244, 0.77019683],[0.11316102, 0.59354993, 0.37849038]])
>>> d = np.random.uniform(-1,1,10)
>>> d
array([-0.34374858,-0.27026865,0.27073922,-0.42654097,-0.38736897,0.16293278, -0.79578655, -0.04825995,  0.28444576,  0.99118406])
```

### 特殊数组

- `zeros`数组：全零数组，元素全为零。
- `ones`数组：全1数组，元素全为1。
- `empty`数组：空数组，元素全近似为0。

```python
>>> zeros((3,4))
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
>>> ones((2,3,4),dtype=int16)
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)
>>> empty((5,3))
array([[6.23042070e-307, 1.42417221e-306, 1.37961641e-306],
       [1.11261027e-306, 1.11261502e-306, 1.42410839e-306],
       [7.56597770e-307, 6.23059726e-307, 1.42419530e-306],
       [7.56599128e-307, 1.11260144e-306, 6.89812281e-307],
       [2.22522596e-306, 2.22522596e-306, 2.56761491e-312]])
```

- 数组索引

Numpy数组每个元素，每行元素，每列元素都可以用索引访问。

```python
>>> c=arange(24).reshape(2,3,4) # reshape()改变数组形状
>>> print(c)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
>>> print(c[1,2,:])
[20 21 22 23]
>>> print(c[0,1,2])
6
```

- 数组运算
  - 算术运算：数组的加减乘除以及乘方运算方式为，相应位置的元素分别进行运算。

```python
>>> a=array([20,30,40,50])
>>> aa=arange(1,5)
>>> a/aa
array([20., 15., 13.33333333, 12.5])
>>> b=arange(4)
>>> b
array([0, 1, 2, 3])
>>> c=a-b
>>> c
array([20, 29, 38, 47])
>>> b**2
array([0, 1, 4, 9], dtype=int32)
>>> A=array([[1,1],[0,1]])
>>> b=array([[2,0],[3,4]])
>>> A*b
array([[2, 0],[0, 4]])
>>> A.sum()
3
>>> A.min()
0
>>> A.max()
1
```

- 逻辑运算

```python
arr > a : 返回arr中大于a的一个布尔值数组
arr[arr>a] : 返回arr中大于a的数据构成的一维数组
np.all(): 括号内全为真则返回真，有一个为假则返回false
np.any() : 括号内全为假则返回假，有一个为真则返回真
np.where(): 三元预算符, 判断同时赋值
如：np.where(arr>0, 1, 0)
复合逻辑运算：
	与：np.logical_and(): 括号为一系列表达式
	或：np.logical_or() 
```

- 统计运算

```python
统计指标函数：min, max, mean, median, var, std
np.函数名
ndarray.方法名
axis参数：axis=0代表列，axis=1代表行
最大值最小值的索引函数：
	np.argmax(arr, axis=)
	np.argmin(arr, axis=)
```

### 数组的拷贝

数组的拷贝分浅拷贝和深拷贝两种，浅拷贝通过数组变量的赋值完成，深拷贝使用数组对象的`copy`方法。浅拷贝只拷贝数组的引用，如果对拷贝进行修改，源数组也将修改。如下：

```python
>>> a=ones((2,3))
>>> a
array([[1., 1., 1.],[1., 1., 1.]])
>>> b=a
>>> b[1,2]=2
>>> a
array([[1., 1., 1.],[1., 1., 2.]])
>>> b
array([[1., 1., 1.],[1., 1., 2.]])
```

深拷贝会复制一份和源数组一样的数组，新数组与源数组会存放在不同内存位置，因此对新数组的修改不会影响源数组。如下：

```python
>>> a=ones((2,3))
>>> b=a.copy()
>>> b[1,2]=2
>>> a
array([[1., 1., 1.],[1., 1., 1.]])
>>> b
array([[1., 1., 1.],[1., 1., 2.]])
```

### 广播机制

`numpy`中不同维度的数组是可以进行算数运算的，只要满足广播机制即可。

```python
广播机制:
1.数组拥有相同形状 --->（3，4）+（3，4）
2.当前维度相等    --->（3，4）+（4，）
3.当前维度有一个是1--->(3,1,5)+(1,3,5)
```

### 分割与合并

`np.hstack((a,b))`：按行合并，要求`a`和`b`的行数相同
		`np.vstack((a,b))`：按列合并，要求`a`和`b`的列数相同
		`np.c_[a,b]`：用法如同`np.hstack((a,b))`
		`np.r_[a,b]`：用法如同`np.vstack((a,b))`

```python
>>> a = np.array([1,2,3])
>>> b = np.array([4,5,6])
>>> a,b
(array([1, 2, 3]), array([4, 5, 6]))
>>> np.hstack((a,b))
array([1, 2, 3, 4, 5, 6])
>>> np.vstack((a,b))
array([[1, 2, 3],[4, 5, 6]])
```

`np.concatenate((a,b), axis = 1)`：按行合并，要求a和b的行数相同

`np.concatenate((a,b), axis = 0)`：按列合并，要求a和b的列数相同

注意：如 果 不 指 定 a x i s ， 则 默 认 a x i s = 0 ， 即 按 列 合 并 。并且一维数组只能按行合并如果不指定axis，则默认axis=0，即按列合并。并且一维数组只能按行合并}如果不指定axis，则默认axis=0，即按列合并。并且一维数组只能按行合并

```python
>>> a = np.array([1,2,3]
>>> b = np.array([4,5,6])
>>> np.concatenate((a,b),axis=0)
array([1, 2, 3, 4, 5, 6])
>>> np.concatenate((a,b),axis=1) # a，b都是一维数组，只能按axis=0合并
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
numpy.AxisError: axis 1 is out of bounds for array of dimension 1
>>> x = np.array([[1,2],[3,4]])
>>> y = np.array([[5,6]])
>>> np.concatenate((x,y),axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.concatenate((x,y.T),axis=1) # y.T表示将y数组转置
array([[1, 2, 5],
       [3, 4, 6]])
```

`np.split(arr, n)`：n要么是整数，要么是列表，用来进行划分，n为整数时必须是能均匀划分

`np.array_split(arr, n)`：类似上面的用法，但是可以不均等划分

```python
>>> x = np.arange(9.0)
>>> np.split(x, 3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]
>>> x = np.arange(8.0)
>>> np.split(x, [3, 5, 6, 10])
[array([ 0.,  1.,  2.]),
 array([ 3.,  4.]),
 array([ 5.]),
 array([ 6.,  7.]),
 array([], dtype=float64)]
 
>>> x = np.arange(8.0)
>>> np.array_split(x, 3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]
 
>>> x = np.arange(7.0)
>>> np.array_split(x, 3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.]), array([ 5.,  6.])]
```

### numpy降维

`ravel()`：返回一维数组，但是改变返回的一维数组内容后，原数组的值也会相应改变    	   `flatten()`：返回一维数组，改变返回的数组不影响原数组

```python
>>> a
array([[1, 2, 3],
       [7, 8, 9]])
>>> b
array([[4, 5, 6],
       [1, 2, 3]])
>>> c = a.ravel()
>>> c
array([1, 2, 3, 7, 8, 9])
>>> d = b.flatten()
>>> d
array([4, 5, 6, 1, 2, 3])
>>> c[0]=100
>>> c
array([100,   2,   3,   7,   8,   9])
>>> a
array([[100,   2,   3],
       [  7,   8,   9]])
>>> d[0]=100
>>> d
array([[100, 100],
       [  6,   1],
       [  2,   3]])
>>> b
array([[4, 5, 6],
       [1, 2, 3]])

```

## 矩阵

### 创建矩阵

Numpy的矩阵对象与数组对象相似，主要不同之处在于，矩阵对象的计算遵循矩阵数学运算规律。矩阵使用matrix函数创建。

```python、
>>> A=matrix('1.0 2.0;3.0 4.0')
>>> A
matrix([[1., 2.],
        [3., 4.]])
>>> b=matrix([[1.0,2.0],[3.0,4.0]])
>>> b
matrix([[1., 2.],
        [3., 4.]])
>>> type(A)
<class 'numpy.matrixlib.defmatrix.matrix'>

```

### 矩阵计算

矩阵的常用数学运算有转置，乘法，求逆等。

```python
>>> A.T      #转置
matrix([[1., 3.],
        [2., 4.]])
>>> x=matrix('5.0 7.0')
>>> y=x.T
>>> y
matrix([[5.],
            [7.]])
>>> print(A*y)   #矩阵乘法
[[19.]
 [43.]]
>>> print(A.I)   #逆矩阵
[[-2.   1. ]
 [ 1.5 -0.5]]

```

## Numpy线性代数相关函数

- `numpy.dot()`

此函数返回两个数组的`点积`。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。

```python
>>> a=np.array([[1,2],[3,4]])
>>> b=np.array([[11,12],[13,14]])
>>> np.dot(a,b)
array([[37, 40],     #[[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]]
       [85, 92]])

```

- `numpy.inner()`

此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。

```python
>>> x=np.array([1,2,3])
>>> y=np.array([0,1,0])
>>> print(np.inner(x,y))
2      # 等价于 1*0+2*1+3*0
```

- `numpy.matmul()`

函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。
另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。

```python
#对二维数组（列表），就相当于矩阵乘法
>>> a=[[1,0],[0,1]]
>>> b=[[4,1],[2,2]]
>>> print(np.matmul(a,b))
[[4 1]
 [2 2]]
 #二维和一维运算
 >>> a=[[1,0],[0,1]]
>>> b=[1,2]
>>> print(np.matmul(a,b))
[1 2]
>>> print(np.matmul(b,a))
[1 2]
#维度大于2的
>>> a=np.arange(8).reshape(2,2,2)
>>> b=np.arange(4).reshape(2,2)
>>> print(np.matmul(a,b))
[[[ 2  3]
  [ 6 11]]

 [[10 19]
  [14 27]]]

```

- `numpy.linalg.det()`

行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。
换句话说，对于矩阵`[[a，b]，[c，d]]`，行列式计算为`ad-bc`。 较大的方阵被认为是 2×2 矩阵的组合。

`numpy.linalg.det()`函数计算输入矩阵的行列式。

```python
>>> a=np.array([[1,2],[3,4]])
>>> print(np.linalg.det(a))
-2.0000000000000004
>>> b=np.array([[6,1,1],[4,-2,5],[2,8,7]])
>>> print(b)
[[ 6  1  1]
 [ 4 -2  5]
 [ 2  8  7]]
>>> print(np.linalg.det(b))
-306.0
>>> print(6*(-2*7-5*8)-1*(4*7-5*2)+(4*8- -2*2))
-306
```

- `numpy.linalg.solve()`

该函数给出了矩阵形式的线性方程的解。
例：
x + y + z = 6
2y + 5z = -4
2x + 5y - z = 27
写成矩阵形势：

![image-20201110214209253](https://gitee.com/zr001/writeimges/raw/master/img/image-20201110214209253.png)

可表示为AX=B，即求X=A^(-1)B，逆矩阵可以用numpy.linalg.inv()函数来求

```python
>>> x=np.array([[1,2],[3,4]])
>>> y=np.linalg.inv(x)
>>> x
array([[1, 2],
       [3, 4]])
>>> y
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
>>> np.dot(x,y)
array([[1.0000000e+00, 0.0000000e+00],
       [8.8817842e-16, 1.0000000e+00]])

```

计算线性方程的解

```python
a=np.array([[1,1,1],[0,2,5],[2,5,-1]])
print('数组a:')
print(a)
ainv=np.linalg.inv(a)
print('a的逆矩阵')
print(ainv)
print('矩阵b:')
b=np.array([[6],[-4],[27]])
print(b)
print('计算：A^(-1)B:')
x=np.linalg.solve(a,b)
print(x)

```

![image-20201110214320887](https://gitee.com/zr001/writeimges/raw/master/img/image-20201110214320887.png)

test